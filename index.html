<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Drakoria ‚Äî Portals+Aggro Fix</title>
<style>
:root{
  --bg:#0b1224; --panel:#0f172a; --stroke:#1f2a44; --text:#e5e7eb; --muted:#9ca3af;
  --tileA:#0e2a1e; --tileB:#123022; --block:#15223b;
  --player:#3b82f6; --enemy:#ef4444; --shadow:#0006; --hpBack:#1f2937;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--stroke)}
header .muted{color:var(--muted);margin-left:8px}
header .btn{background:#26325a;color:#fff;border:1px solid #31406e;border-radius:8px;padding:6px 10px;cursor:pointer}
main{max-width:1400px;margin:14px auto;padding:12px;background:var(--panel);border:1px solid var(--stroke);border-radius:12px;position:relative}
#game{display:block;width:100%;height:auto;border-radius:10px;border:1px solid var(--stroke);background:#0a1630;image-rendering:pixelated;touch-action:none}
.help{margin:.6rem 0 0;color:#a1a1aa}
#status{margin-top:8px;color:var(--muted)}
.err{position:fixed;left:50%;top:70px;transform:translateX(-50%);background:#7f1d1d;color:#fff;border:1px solid #fecaca;border-radius:8px;padding:8px 12px;z-index:50;font-weight:600;max-width:90vw;white-space:pre-wrap;display:none}

/* Log */
.log{position:fixed; left:16px; bottom:16px; width:300px; max-width:80vw;
  background:rgba(15,23,42,.9); border:1px solid #1f2a44; border-radius:10px; padding:8px 10px; z-index:26}
.log .h{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-weight:700}
.log .b{max-height:160px; overflow:auto; font:12px/1.3 system-ui}
.log .line{margin:2px 0}
.log .dmg{color:#fca5a5}
.log .heal{color:#86efac}
.log .sys{color:#93c5fd}

/* Game Over */
.death{position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:60}
.death.hidden{display:none}
.death-box{background:#0f172a; border:1px solid #1f2a44; padding:14px; border-radius:12px; width:min(420px,92vw); box-shadow:0 18px 44px rgba(0,0,0,.55)}
.death-title{font-weight:800; font-size:18px; margin-bottom:8px}
.death-sub{color:#cbd5e1; margin-bottom:12px}
.death-actions{display:flex; gap:8px; justify-content:flex-end}
.btn{border:1px solid #31406e;background:#2563eb;color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
.btn:disabled{background:#1f2a44;color:#9aa0ad;cursor:not-allowed}

/* Character (stats) */
.char{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:520px; max-width:95vw;
     background:#0f172a; border:1px solid #1f2a44; border-radius:12px; box-shadow:0 18px 44px rgba(0,0,0,.45); z-index:46}
.char-h{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #1f2a44;font-weight:700}
.char-x{width:32px;height:26px;border-radius:6px;border:1px solid #31406e;background:#26325a;color:#fff;cursor:pointer}
.char-b{padding:12px}
.stat-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
.stat{display:flex; justify-content:space-between; align-items:center; background:#0b1224; border:1px solid #2a355c; border-radius:10px; padding:8px}
.stat .k{color:#93c5fd; font-weight:700}
.stat .v{font-weight:700}
.hidden{display:none}

/* Toast */
.toast{position:fixed; left:50%; bottom:84px; transform:translateX(-50%); background:rgba(15,23,42,.9); border:1px solid #1f2a44; color:#e5e7eb; padding:6px 10px; border-radius:10px; z-index:55; display:none}
</style>
</head>
<body>
<header>
  <div><strong>Drakoria</strong> <span class="muted">portals+aggro fix</span></div>
  <div>
    <button id="btnChar" class="btn">Personaggio</button>
    <button id="btnSave" class="btn">Save</button>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnReset" class="btn">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="1344" height="768" aria-label="Gioco"></canvas>
  <p class="help">
    Tap per muoverti ‚Ä¢ tap su un nemico per target ‚Ä¢ doppio tap/press prolungato per auto-inseguire ‚Ä¢ SPAZIO/üó°Ô∏è attacca.  
    Portale viola tra Spawn ‚Üî Main. Pannello <b>Personaggio</b> per statistiche & XP.
  </p>
  <div id="status"></div>
</main>

<section class="log" id="logPanel"><div class="h"><span>Log</span></div><div id="logBody" class="b"></div></section>
<div id="errBox" class="err"></div>
<div id="toast" class="toast"></div>

<!-- Game Over -->
<div id="deathOverlay" class="death hidden" role="dialog" aria-modal="true" aria-label="Game Over">
  <div class="death-box">
    <div class="death-title">Sei morto</div>
    <div class="death-sub">Respawn ti riporta allo spawn con vita piena.</div>
    <div class="death-actions">
      <button id="deathRespawn" class="btn">Respawn</button>
      <button id="deathReset" class="btn">Reset</button>
    </div>
  </div>
</div>

<!-- Character (stats) -->
<section id="charWin" class="char hidden" role="dialog" aria-modal="true" aria-label="Personaggio">
  <div class="char-h"><span>Personaggio</span><button id="charClose" class="char-x">√ó</button></div>
  <div class="char-b">
    <div id="charBasics" class="stat-grid" style="margin-bottom:10px"></div>
    <div id="charStats" class="stat-grid"></div>
  </div>
</section>

<script>
(function(){
  const BUILD='PORTALS-AGGRO-FIX';
  const SAVE_KEY='save_portals_aggro_fix';
  const cv=document.getElementById('game'); const ctx=cv.getContext('2d');

  /* UI */
  const statusEl=document.getElementById('status');
  const errBox=document.getElementById('errBox');
  const logBody=document.getElementById('logBody');
  const toastEl=document.getElementById('toast');
  const deathOverlay=document.getElementById('deathOverlay');
  const deathRespawn=document.getElementById('deathRespawn');
  const deathReset=document.getElementById('deathReset');
  const btnChar=document.getElementById('btnChar');
  const charWin=document.getElementById('charWin');
  const charClose=document.getElementById('charClose');
  const charBasics=document.getElementById('charBasics');
  const charStats=document.getElementById('charStats');
  const btnSave=document.getElementById('btnSave');
  const btnLoad=document.getElementById('btnLoad');
  const btnReset=document.getElementById('btnReset');

  function panic(where,e){
    errBox.style.display='block';
    errBox.textContent='ERRORE '+where+': '+(e && (e.message||e));
    console.error('[PANIC]', where, e);
  }
  function toast(msg){
    toastEl.textContent=msg;
    toastEl.style.display='block';
    clearTimeout(toastEl.__t);
    toastEl.__t=setTimeout(()=>toastEl.style.display='none',1100);
  }
  function logLine(msg,cls){ const t=new Date(); const hh=String(t.getHours()).padStart(2,'0'), mm=String(t.getMinutes()).padStart(2,'0'), ss=String(t.getSeconds()).padStart(2,'0'); logBody.innerHTML+=`<div class="line ${cls||''}">[${hh}:${mm}:${ss}] ${escapeHtml(msg)}</div>`; logBody.scrollTop=logBody.scrollHeight; }
  function logDmg(m){ logLine(m,'dmg'); }
  function logHeal(m){ logLine(m,'heal'); }
  function logSys(m){ logLine(m,'sys'); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  /* World */
  const COLS=21, ROWS=12, TILE=64; cv.width=COLS*TILE; cv.height=ROWS*TILE;
  const WORLD={ current:'spawn', portals:makePortals() };
  const THEMES={ main:{'--tileA':'#0e2a1e','--tileB':'#123022'}, spawn:{'--tileA':'#1e1f3a','--tileB':'#23264a'} };
  let map=[];
  function makePortals(){ const mid=ROWS>>1; return { main:[{x:1,y:mid,to:'spawn',tx:COLS-2,ty:mid}], spawn:[{x:COLS-2,y:mid,to:'main',tx:1,ty:mid}] }; }
  function isPortalTile(world,x,y){ const l=WORLD.portals[world]||[]; for(let i=0;i<l.length;i++){ const p=l[i]; if(p.x===x&&p.y===y) return true; } return false; }
  function applyTheme(vars){ const root=document.documentElement.style; for(const k in vars) root.setProperty(k, vars[k]); }
  function buildMap(name){
    const m=[]; for(let y=0;y<ROWS;y++){ const row=[]; for(let x=0;x<COLS;x++) row.push(0); m.push(row); }
    if(name==='main'){ for(let i=0;i<16;i++){ const bx=(Math.random()*COLS|0), by=(Math.random()*ROWS|0); if(isPortalTile('main',bx,by)) continue; m[by][bx]=1; } }
    return {map:m, theme:(name==='main')?THEMES.main:THEMES.spawn};
  }

  /* Utils */
  function inside(x,y){ return x>=0&&y>=0&&x<COLS&&y<ROWS; }
  function rndInt(a,b){ return a+((Math.random()*(b-a+1))|0); }
  function walkable(x,y){ if(!inside(x,y)) return false; if(map[y][x]===1) return false; return true; }
  function tileFree(x,y){ if(map[y][x]!==0) return false; if(x===player.x&&y===player.y) return false; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===x&&e.y===y) return false; } return true; }
  function chebyshev(a,b){ const dx=Math.abs(a.x-b.x), dy=Math.abs(a.y-b.y); return dx>dy?dx:dy; }
  function randEmpty(){ for(let t=0;t<200;t++){ const x=rndInt(0,COLS-1), y=rndInt(0,ROWS-1); if(walkable(x,y)&&tileFree(x,y)) return {x,y}; } return {x:1,y:1}; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function getVar(n){ const cs=getComputedStyle(document.documentElement); return cs.getPropertyValue(n).trim(); }

  /* BFS pathfinding */
  function bfs(sx,sy,tx,ty){
    if(!walkable(tx,ty)) return null;
    const q=[{x:sx,y:sy}], prev={}, seen={}; let head=0; seen[sx+','+sy]=1;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(head<q.length){
      const c=q[head++]; if(c.x===tx&&c.y===ty){
        const path=[]; let k=tx+','+ty;
        while(prev[k]){ const s=k.split(','); path.push({x:+s[0],y:+s[1]}); k=prev[k].x+','+prev[k].y; }
        path.reverse(); return path;
      }
      for(let d=0; d<4; d++){
        const nx=c.x+dirs[d][0], ny=c.y+dirs[d][1], kk=nx+','+ny;
        if(!walkable(nx,ny)||seen[kk]) continue; seen[kk]=1; prev[kk]={x:c.x,y:c.y}; q.push({x:nx,y:ny});
      }
    }
    return null;
  }
  function bfsToAdjacencySmart(sx,sy,tx,ty,etype){
    const opts=[[tx+1,ty],[tx-1,ty],[tx,ty+1],[tx,ty-1]]; let best=null, bestScore=1e9;
    for(let i=0;i<opts.length;i++){
      const ax=opts[i][0], ay=opts[i][1]; if(!walkable(ax,ay)) continue;
      let occ=false; for(let j=0;j<enemies.length;j++){ const e=enemies[j]; if(e.x===ax&&e.y===ay){ occ=true; break; } }
      if(occ) continue;
      const p=bfs(sx,sy,ax,ay); if(!p) continue; let score=p.length; if(etype==='ranged'&&(ax===tx||ay===ty)) score+=2;
      if(score<bestScore){ bestScore=score; best=p; }
    }
    return best;
  }

  /* Tween */
  let MOVE_MS=110;
  function startTween(o,fx,fy,tx,ty,now){ o.vFromX=fx; o.vFromY=fy; o.vToX=tx; o.vToY=ty; o.vStart=now; o.vEnd=now+MOVE_MS; if(o.vx==null)o.vx=fx; if(o.vy==null)o.vy=fy; }
  function tweenUpdate(o,now){
    if(!o) return; const has=(o.vStart&&o.vEnd&&o.vEnd>o.vStart);
    if(has && now<o.vEnd){ let t=(now-o.vStart)/(o.vEnd-o.vStart); t=t*t*(3-2*t); o.vx=o.vFromX+(o.vToX-o.vFromX)*t; o.vy=o.vFromY+(o.vToY-o.vFromY)*t; }
    else { if(o.x!=null) o.vx=o.x; if(o.y!=null) o.vy=o.y; o.vStart=0; o.vEnd=0; }
  }
  function updateTweens(){ const now=performance.now(); tweenUpdate(player,now); for(let i=0;i<enemies.length;i++) tweenUpdate(enemies[i],now); for(let j=0;j<projectiles.length;j++) tweenUpdate(projectiles[j],now); }

  /* Player + Stats (ridotto) */
  const player={
    x:12,y:4,
    baseMaxHp:100, baseAtkMin:6, baseAtkMax:12,
    maxHp:100, hp:100, atkMin:6, atkMax:12,
    baseCrit:0.10,
    coins:0,pots:1,lastAtk:0,atkCd:450,lvl:1,exp:0,
    stats:{ atkSpeed:0.00, critDmg:0.50, luck:0.00, defense:0, mitigation:0.00, projRes:0.00, bleedRes:0.00 },
    status:{ bleed:null }
  };
  const MAX_LVL=99;
  function xpNeeded(l){ return Math.floor(50 * Math.pow(l, 1.5)); }
  function gainXP(n){
    if(player.lvl>=MAX_LVL) return;
    player.exp+=n;
    while(player.lvl<MAX_LVL && player.exp>=xpNeeded(player.lvl)){
      player.exp-=xpNeeded(player.lvl); levelUp();
    }
    renderCharIfOpen();
  }
  function levelUp(){
    player.lvl=Math.min(MAX_LVL, player.lvl+1);
    player.baseMaxHp += 2; player.baseAtkMin += .2; player.baseAtkMax += .3;
    if(player.lvl%5===0){
      player.stats.defense += 1;
      player.stats.mitigation = clamp((player.stats.mitigation||0)+.01,0,0.60);
      player.stats.atkSpeed   = clamp((player.stats.atkSpeed  ||0)+.01,0,0.50);
      player.stats.projRes    = clamp((player.stats.projRes   ||0)+.01,0,0.60);
      player.stats.bleedRes   = clamp((player.stats.bleedRes  ||0)+.01,0,0.70);
      player.stats.luck       = clamp((player.stats.luck      ||0)+.005,0,0.50);
    }
    player.hp=Math.min(player.maxHp, player.hp + Math.round(player.maxHp*0.10));
    recomputeStats(false);
    logSys('Level up ‚Üí LV '+player.lvl);
    toast('LV '+player.lvl);
  }
  function getCritChance(){ return clamp(player.baseCrit + (player.stats.luck||0), 0, 0.90); }
  function getAtkCd(){ const eff=player.atkCd*(1-clamp(player.stats.atkSpeed||0,0,0.50)); return Math.max(180, Math.floor(eff)); }
  function recomputeStats(heal){
    player.maxHp=Math.round(player.baseMaxHp);
    player.atkMin=Math.round(player.baseAtkMin);
    player.atkMax=Math.round(player.baseAtkMax);
    if(heal) player.hp=player.maxHp; if(player.hp>player.maxHp) player.hp=player.maxHp;
    renderCharIfOpen();
  }

  /* Enemies */
  let enemies=[], projectiles=[];
  let _eid=1; function giveId(e){ e.id=_eid++; return e; }
  function makeArcher(x,y){
    const e={ kind:'archer', type:'ranged', x,y, spawnX:x, spawnY:y,
      hp:44, maxHp:44, atkCd:1200, lastShot:0, rangeMin:3, rangeMax:7,
      aggro:false, aggroRange:5, leashRange:15, loseAggroMs:6000, lastSeenTs:0,
      moveTick:0, moveEvery:6, path:[], windupMs:400
    };
    e.vx=x; e.vy=y; return giveId(e);
  }
  function createPatrolGroup(count, anchorX, anchorY, radius){
    for(let i=0;i<count;i++){
      const pos=findFreeNear(anchorX,anchorY,radius||2,30);
      const e=makeArcher(pos.x,pos.y);
      e.groupAnchor={x:anchorX,y:anchorY}; e.patrolRadius=radius||2;
      enemies.push(e);
    }
  }
  function spawnMain(){
    enemies.length=0;
    // gruppi sul lato destro, lontani dal portale (che √® a x=1)
    createPatrolGroup(5, COLS-5, 2, 2);
    createPatrolGroup(5, COLS-5, ROWS-3, 2);
  }
  function findFreeNear(cx,cy,r,tries){ tries=tries||30;
    for(let k=0;k<tries;k++){ const nx=clamp(Math.round(cx+rndInt(-r,r)),0,COLS-1), ny=clamp(Math.round(cy+rndInt(-r,r)),0,ROWS-1);
      if(walkable(nx,ny)&&tileFree(nx,ny)&&!isPortalTile(WORLD.current,nx,ny)) return {x:nx,y:ny};
    } return randEmpty();
  }

  /* Init spawn */
  (function initSpawn(){
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn'; enemies.length=0; recomputeStats(true);
  })();

  /* Input & HUD */
  const HUD={ atk:null, pot:null, char:null };
  function layoutHud(){
    HUD.atk  = { x: cv.width - 86,  y: cv.height - 86, w: 72, h: 72 };
    HUD.pot  = { x: cv.width - 166, y: cv.height - 86, w: 72, h: 72 };
    HUD.char = { x: cv.width - 86,  y: 14,             w: 72, h: 54  };
  }
  window.addEventListener('resize', layoutHud, false);
  layoutHud();

  let target=null, autoChase=false, lastEnemyTapTs=0, lastEnemyTapId=-1;
  let pathQueue=[], holdTimer=null, destMarker=null;
  let dead=false;

  btnChar.onclick=()=>{ charWin.classList.toggle('hidden'); renderCharPanel(); };
  charClose.onclick=()=>{ charWin.classList.add('hidden'); };

  function canvasToTile(ev){
    const r=cv.getBoundingClientRect(), t=ev.touches&&ev.touches[0];
    const cx=t?t.clientX:ev.clientX, cy=t?t.clientY:ev.clientY;
    const sx=(cx-r.left)*(cv.width/r.width), sy=(cy-r.top)*(cv.height/r.height);
    const tx = Math.max(0, Math.min(COLS-1, (sx/TILE)|0));
    const ty = Math.max(0, Math.min(ROWS-1, (sy/TILE)|0));
    return {sx, sy, tx, ty};
  }
  function enemyRect(e){ const x=e.x*TILE+TILE/2-16, y=e.y*TILE+TILE/2-22; return {x,y,w:32,h:36}; }
  function inRect(px,py,r){ return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h; }
  function getEnemyAtScreen(sx,sy){ for(let i=0;i<enemies.length;i++){ const ee=enemies[i]; if(inRect(sx,sy,enemyRect(ee))) return ee; } return null; }

  function onPointerDown(ev){
    if(dead) return;
    const m=canvasToTile(ev), pos={sx:m.sx,sy:m.sy};
    clearTimeout(holdTimer);
    holdTimer=setTimeout(()=>{ const enemy=getEnemyAtScreen(pos.sx,pos.sy); if(enemy){ target=enemy; autoChase=true; pathQueue=[]; updateTargetFrame(); toast('Auto-inseguimento'); draw(); } },500);
  }
  function onPointerUp(ev){
    if(dead) return;
    clearTimeout(holdTimer);
    const m=canvasToTile(ev), now=performance.now();

    if(inRect(m.sx,m.sy,HUD.atk)){ tryAttackAdjacent(); return; }
    if(inRect(m.sx,m.sy,HUD.pot)){ usePotion(); return; }
    if(inRect(m.sx,m.sy,HUD.char)){ charWin.classList.toggle('hidden'); renderCharPanel(); return; }

    const clicked=getEnemyAtScreen(m.sx,m.sy);
    if(clicked){
      if(lastEnemyTapId===clicked.id && (now-lastEnemyTapTs)<=350){ target=clicked; autoChase=true; pathQueue=[]; }
      else { target=clicked; autoChase=false; }
      lastEnemyTapId=clicked.id; lastEnemyTapTs=now; updateTargetFrame(); draw(); return;
    }

    autoChase=false;
    const p=bfs(player.x,player.y,m.tx,m.ty);
    if(p && p.length){ pathQueue=p; destMarker={x:m.tx,y:m.ty,ttl:1400}; }
    else{
      const dx=Math.sign(m.tx-player.x), dy=Math.sign(m.ty-player.y);
      const tryFirst=(Math.abs(m.tx-player.x)>=Math.abs(m.ty-player.y))?[{x:player.x+dx,y:player.y},{x:player.x,y:player.y+dy}]:[{x:player.x,y:player.y+dy},{x:player.x+dx,y:player.y}];
      for(let k=0;k<tryFirst.length;k++){ const nxt=tryFirst[k]; if(inside(nxt.x,nxt.y)&&walkable(nxt.x,nxt.y)){ pathQueue=[nxt]; destMarker={x:nxt.x,y:nxt.y,ttl:700}; break; } }
    }
    if(target && chebyshev(player,target)===1 && (now-player.lastAtk)>=getAtkCd()) { attackEnemy(target); return; }
    draw(); updateTargetFrame();
  }
  cv.addEventListener('pointerdown', onPointerDown, {passive:false});
  cv.addEventListener('pointerup', onPointerUp, {passive:false});
  cv.addEventListener('click', onPointerUp, false);
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.key===' ') tryAttackAdjacent(); }, false);

  function tryAttackAdjacent(){
    const now=performance.now(); if(now-player.lastAtk<getAtkCd()) return false;
    if(target && chebyshev(player,target)===1){ attackEnemy(target); return true; }
    for(let i=0;i<enemies.length;i++){ const en=enemies[i]; if(chebyshev(player,en)===1){ attackEnemy(en); return true; } }
    return false;
  }

  /* Combat minimal */
  const dmgTexts=[];
  function addDmgText(tx,ty,txt,color){ const px=tx*TILE+TILE/2, py=ty*TILE+TILE/2-28; dmgTexts.push({x:px,y:py,txt,color,ttl:700,vy:-0.04}); }
  function updateDmgTexts(dt){ for(let i=dmgTexts.length-1;i>=0;i--){ const d=dmgTexts[i]; d.ttl-=dt; d.y+=d.vy*dt; if(d.ttl<=0) dmgTexts.splice(i,1); } }
  function drawDmgTexts(){ for(let i=0;i<dmgTexts.length;i++){ const d=dmgTexts[i]; const a=Math.max(0,Math.min(1,d.ttl/700)); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=d.color; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(d.txt,d.x,d.y); ctx.restore(); } }
  function rollCrit(ch){ return Math.random() < ch; }
  function attackEnemy(t){
    const now=performance.now(); player.lastAtk=now;
    const base=rndInt(player.atkMin,player.atkMax);
    const crit=rollCrit(getCritChance()); const mult=crit?(1+(player.stats.critDmg||0)):1;
    const dmg=Math.max(0, Math.floor(base*mult));
    t.hp=Math.max(0, t.hp-dmg);
    addDmgText(t.x,t.y,(crit?'CRIT ':'-')+dmg, crit?'#facc15':'#ffd166');
    if(t.hp===0){
      if(target===t){ target=null; autoChase=false; }
      logSys('Nemico sconfitto. +25 XP');
      enemies.splice(enemies.indexOf(t),1);
      gainXP(25);
      setTimeout(()=>{ if(WORLD.current==='main'){ const s=randEmpty(); enemies.push(makeArcher(s.x,s.y)); } }, 1000);
    }
    draw();
  }
  function applyDamageReduction(amount, source){
    let dmg=Math.max(0, amount-(player.stats.defense|0));
    const miti=clamp(player.stats.mitigation||0,0,0.60); dmg=Math.floor(dmg*(1-miti));
    if(source==='projectile'){ const pr=clamp(player.stats.projRes||0,0,0.60); dmg=Math.floor(dmg*(1-pr)); }
    return Math.max(0,dmg|0);
  }
  function takePlayerDamage(amount,label,source){
    const dmg=applyDamageReduction(amount,source);
    player.hp=Math.max(0, player.hp-dmg); addDmgText(player.x,player.y,label+dmg,'#ff6b6b');
    if(player.hp===0) gameOver();
  }

  function gameOver(){
    dead=true; autoChase=false; pathQueue=[]; target=null;
    cv.style.filter='grayscale(1)'; cv.style.opacity='0.6';
    deathOverlay.classList.remove('hidden');
  }
  deathRespawn.onclick=()=>{
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn';
    const exit=findSafeExit('spawn', COLS-2, (ROWS>>1), /*minGap*/1);
    setPlayerPos(exit.x, exit.y);
    player.hp=player.maxHp;
    enemies.length=0; projectiles.length=0; pathQueue=[];
    dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
    teleportGuardUntil=performance.now()+600;
    entryAggroSilenceUntil=performance.now()+900;
    draw();
  };
  deathReset.onclick=()=>location.reload();

  /* LoS */
  function hasLoS(ax,ay,bx,by){
    if(ax===bx){ const step=(ay<by)?1:-1; for(let y=ay+step; y!==by; y+=step){ if(map[y][ax]===1) return false; } return true; }
    if(ay===by){ const st=(ax<bx)?1:-1; for(let x=ax+st; x!==bx; x+=st){ if(map[ay][x]===1) return false; } return true; }
    return false;
  }

  /* Portals: safe exit + guards (robusto) */
  let teleportGuardUntil=0;              // blocca il retrigger per un po'
  let entryAggroSilenceUntil=0;          // i mob non aggrano subito
  let mustMoveOffExit=false;             // finch√© non ti sposti dalla tile d'uscita, ignora portali
  let lastExit={x:-1,y:-1};              // ricorda l‚Äôuscita corrente

  function setPlayerPos(x,y){ player.x=x; player.y=y; player.vx=x; player.vy=y; }

  function findSafeExit(worldName, px, py, minGapFromPortal){
    const gap = (minGapFromPortal==null)?1:minGapFromPortal;
    const candidates = [
      [ 1, 0],[-1, 0],[ 0, 1],[ 0,-1],
      [ 1, 1],[-1, 1],[ 1,-1],[-1,-1],
      [ 2, 0],[-2, 0],[ 0, 2],[ 0,-2],
      [ 3, 0],[-3, 0],[ 0, 3],[ 0,-3]
    ];
    // prova vicini NON-portale e non adiacenti al portale (gap)
    function isNearPortal(wx,wy){ const list=WORLD.portals[worldName]||[]; for(let i=0;i<list.length;i++){ const p=list[i]; if(Math.abs(wx-p.x)<=gap && Math.abs(wy-p.y)<=gap) return true; } return false; }
    for(const d of candidates){
      const nx=clamp(px+d[0],0,COLS-1), ny=clamp(py+d[1],0,ROWS-1);
      if(!walkable(nx,ny)) continue;
      if(isPortalTile(worldName,nx,ny)) continue;
      if(isNearPortal(nx,ny)) continue; // evita tile attigue al portale: niente ping-pong
      if(!tileFree(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    // fallback: stessa tile target ma NON portale ‚Üí sposta di 1 in X
    let fx=clamp(px+1,0,COLS-1), fy=py;
    if(!walkable(fx,fy) || isPortalTile(worldName,fx,fy)) fx=clamp(px-1,0,COLS-1);
    return {x:fx,y:fy};
  }

  function checkPortalEnter(){
    const now=performance.now();
    if(now<teleportGuardUntil) return false;
    // finch√© sei sull'ultima tile di uscita, ignora i portali per evitare rimbalzi
    if(mustMoveOffExit && player.x===lastExit.x && player.y===lastExit.y) return false;

    const list=WORLD.portals[WORLD.current]||[];
    for(let i=0;i<list.length;i++){
      const p=list[i];
      if(p.x===player.x && p.y===player.y){
        // teletrasporto
        const next = buildMap(p.to); map=next.map; applyTheme(next.theme); WORLD.current=p.to;
        // se vai in main, prima spawna i mob in zone lontane
        if(WORLD.current==='main'){ spawnMain(); } else { enemies.length=0; projectiles.length=0; }
        // piazza su uscita sicura NON-portale e non adiacente al portale
        const exit = findSafeExit(p.to, p.tx, p.ty, /*minGapFromPortal*/1);
        setPlayerPos(exit.x, exit.y);
        pathQueue.length=0;

        // attiva guardie anti-loop + aggro delay
        teleportGuardUntil = performance.now()+600;
        entryAggroSilenceUntil = performance.now()+900;

        // richiedi di muoversi via dalla tile di uscita prima di poter riusare portali
        mustMoveOffExit = true;
        lastExit = {x:exit.x, y:exit.y};

        logSys('Teletrasporto: '+(WORLD.current==='main'?'Main':'Spawn'));
        draw();
        return true;
      }
    }
    return false;
  }

  /* Render */
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?getVar('--block'):(((x+y)%2===0)?getVar('--tileA'):getVar('--tileB'));
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
    drawPortals();

    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; const ex=(e.vx!=null?e.vx:e.x), ey=(e.vy!=null?e.vy:e.y);
      drawActor(ex,ey,getVar('--enemy'));
      drawHpBar(ex,ey,e.hp,e.maxHp,true,(target===e));
      if(target===e) drawTargetRing(ex,ey);
    }

    const pxv=(player.vx!=null?player.vx:player.x), pyv=(player.vy!=null?player.vy:player.y);
    drawActor(pxv,pyv,getVar('--player')); drawHpBar(pxv,pyv,player.hp,player.maxHp,false,false);

    for(let p=0;p<projectiles.length;p++){
      const pr=projectiles[p]; const ptx=(pr.vx!=null?pr.vx:pr.x), pty=(pr.vy!=null?pr.vy:pr.y);
      const x=ptx*TILE+TILE/2, y=pty*TILE+TILE/2; ctx.fillStyle='#f87171'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
    }

    drawDmgTexts();
    drawHud();

    const need=(player.lvl<MAX_LVL)?xpNeeded(player.lvl):1;
    const ratio=(player.lvl<MAX_LVL)?Math.min(1,player.exp/need):1;
    const guardLeft=Math.max(0, teleportGuardUntil - performance.now())|0;
    const aggroSilLeft=Math.max(0, entryAggroSilenceUntil - performance.now())|0;
    statusEl.textContent=`build:${BUILD} | LV ${player.lvl} ${player.lvl<MAX_LVL?('('+Math.floor(ratio*100)+'%)'):''} | HP ${player.hp}/${player.maxHp} | ATK ${player.atkMin}‚Äì${player.atkMax} | AggroSil ${aggroSilLeft}ms | TPGuard ${guardLeft}ms`;
  }
  function drawPortals(){
    const list=WORLD.portals[WORLD.current]||[];
    ctx.save();
    for(let i=0;i<list.length;i++){
      const p=list[i];
      ctx.fillStyle='#7c3aed'; ctx.globalAlpha=0.95; ctx.fillRect(p.x*TILE+6,p.y*TILE+6,TILE-12,TILE-12);
      ctx.globalAlpha=0.35; ctx.fillRect(p.x*TILE+3,p.y*TILE+3,TILE-6,TILE-6);
    }
    ctx.restore();
  }
  function drawActor(tx,ty,color){
    const x=tx*TILE, y=ty*TILE;
    ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,18,6,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=color; ctx.fillRect(x+TILE/2-16,y+TILE/2-22,32,36);
  }
  function drawHpBar(tx,ty,hp,maxHp,isEnemy,isTarget){
    const x=tx*TILE, y=ty*TILE, w=40, h=6, px=x+TILE/2-w/2, py=y+TILE/2-32;
    const r=Math.max(0,Math.min(1,hp/maxHp));
    let col='#10b981'; if(isEnemy){ if(r<0.66) col='#f59e0b'; if(r<0.33) col='#ef4444'; }
    ctx.fillStyle=getVar('--hpBack'); ctx.fillRect(px,py,w,h);
    ctx.fillStyle=col; ctx.fillRect(px,py,w*r,h);
    ctx.strokeStyle=isTarget?'#f87171':'#0008'; ctx.lineWidth=isTarget?2:1; ctx.strokeRect(px,py,w,h); ctx.lineWidth=1;
  }
  function drawTargetRing(tx,ty){ const x=tx*TILE+TILE/2, y=ty*TILE+TILE/2; ctx.save(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,28,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function drawHudBtn(r, glyph, enabled){ ctx.save(); ctx.globalAlpha=enabled?1:0.55; ctx.fillStyle='rgba(15,23,42,.85)'; ctx.strokeStyle='#1f2a44'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(r.x+12,r.y); ctx.arcTo(r.x+r.w,r.y,r.x+r.w,r.y+r.h,12); ctx.arcTo(r.x+r.w,r.y+r.h,r.x,r.y+r.h,12); ctx.arcTo(r.x,r.y+r.h,r.x,r.y,12); ctx.arcTo(r.x,r.y,r.x+r.w,r.y,12); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.font='28px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#e5e7eb'; ctx.fillText(glyph, r.x + r.w/2, r.y + r.h/2); ctx.restore(); }
  function drawHud(){
    drawHudBtn(HUD.atk, 'üó°Ô∏è', (performance.now()-player.lastAtk)>=getAtkCd());
    drawHudBtn(HUD.pot, 'üçµ', player.pots>0);
    drawHudBtn(HUD.char, 'üë§', true);
    if(destMarker && destMarker.ttl>0){
      const a=Math.min(1, destMarker.ttl/400);
      ctx.save(); ctx.globalAlpha=a; ctx.strokeStyle='#93c5fd'; ctx.lineWidth=2;
      const cx=destMarker.x*TILE+TILE/2, cy=destMarker.y*TILE+TILE/2;
      ctx.beginPath(); ctx.arc(cx,cy,20,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }

  /* Target frame placeholder */
  function updateTargetFrame(){}

  /* Guards movement helper */
  function movedOffExitTile(){ return !(player.x===lastExit.x && player.y===lastExit.y); }

  /* Loop */
  let lastStepTs=performance.now();
  function step(){
    try{
      const now=performance.now();
      const dt=Math.min(200, now-lastStepTs)|0; lastStepTs=now;

      // se ti sei mosso via dalla tile di uscita, riabilita i portali
      if(mustMoveOffExit && movedOffExitTile()) mustMoveOffExit=false;

      // Player path follow
      if(!dead && pathQueue.length){
        const next=pathQueue[0];
        let blocked=!walkable(next.x,next.y);
        for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===next.x&&e.y===next.y){ blocked=true; break; } }
        if(blocked){ pathQueue.length=0; }
        else{
          const fx=player.x, fy=player.y; setPlayerPos(next.x,next.y); startTween(player,fx,fy,player.x,player.y,now);
          pathQueue.shift();
        }
      }

      // Portali (con guard)
      checkPortalEnter();

      // Enemy AI con aggro ‚Äúvicino + LoS‚Äù
      for(let j=0;j<enemies.length;j++){
        const e=enemies[j];
        e.moveTick=(e.moveTick+1)%e.moveEvery;
        const canMove=(e.moveTick===0);

        const distC=chebyshev(e,player);
        // aggro solo se vicino e con LoS (o molto vicino)
        if(!e.aggro && now>=entryAggroSilenceUntil){
          const canAggro = (distC<=e.aggroRange) && (hasLoS(e.x,e.y,player.x,player.y) || distC<=2);
          if(canAggro){ e.aggro=true; e.lastSeenTs=now; }
        }

        const tooFar = chebyshev({x:e.spawnX,y:e.spawnY}, player) > e.leashRange || distC > e.leashRange;
        if(e.aggro){
          if(hasLoS(e.x,e.y,player.x,player.y) || distC<=1) e.lastSeenTs=now;
          if(tooFar || (now - e.lastSeenTs) > e.loseAggroMs){
            e.aggro=false; e.path = bfs(e.x,e.y,e.spawnX,e.spawnY)||[];
          }
        }

        if(e.aggro && now>=entryAggroSilenceUntil){
          const distM=Math.abs(e.x-player.x)+Math.abs(e.y-player.y);
          const inRange = (distM>=e.rangeMin && distM<=e.rangeMax && hasLoS(e.x,e.y,player.x,player.y));
          if(inRange){
            if(now-e.lastShot>=e.atkCd){
              e.lastShot=now;
              setTimeout(()=>{
                const dx=(player.x===e.x)?0:(player.x>e.x?1:-1);
                const dy=(player.y===e.y)?0:(player.y>e.y?1:-1);
                if(dx||dy) projectiles.push({x:e.x,y:e.y,dx,dy,spdTick:0,dmg:rndInt(6,10), vx:e.x, vy:e.y, vStart:0,vEnd:0, bleedChance:0.3});
              }, e.windupMs);
            }
            if(distM<e.rangeMin && canMove){
              const backX=e.x + (player.x<e.x?1:(player.x>e.x?-1:0));
              const backY=e.y + (player.y<e.y?1:(player.y>e.y?-1:0));
              if(walkable(backX,backY) && !(backX===player.x&&backY===player.y)){
                const fx=e.x, fy=e.y; e.x=backX; e.y=backY; startTween(e,fx,fy,e.x,e.y,now);
              }
            }
          } else if(canMove){
            if(chebyshev(e,player)>1 || !hasLoS(e.x,e.y,player.x,player.y)){
              e.path = bfsToAdjacencySmart(e.x,e.y,player.x,player.y,'ranged') || e.path || [];
            }
            tryStepAlongPath(e, now);
          }
        } else if(canMove){
          // rientro
          if((e.x!==e.spawnX || e.y!==e.spawnY)){
            if(!e.path || !e.path.length) e.path=bfs(e.x,e.y,e.spawnX,e.spawnY)||[];
            tryStepAlongPath(e, now);
          }
        }
      }

      // Proiettili
      for(let pi=projectiles.length-1; pi>=0; pi--){
        const pr=projectiles[pi];
        pr.spdTick=(pr.spdTick+1)%2; if(pr.spdTick!==0) continue;
        const nx=pr.x+pr.dx, ny=pr.y+pr.dy;
        if(!inside(nx,ny) || map[ny][nx]===1){ projectiles.splice(pi,1); continue; }
        if(nx===player.x && ny===player.y){
          const base=rndInt(pr.dmg-1, pr.dmg+1);
          takePlayerDamage(base, '-', 'projectile');
          if(Math.random() < (pr.bleedChance||0)){ /* bleed placeholder */ }
          projectiles.splice(pi,1); continue;
        }
        startTween(pr, pr.x, pr.y, nx, ny, now); pr.x=nx; pr.y=ny;
      }

      // Auto-chase & auto-attack
      if(autoChase && target && !dead){
        const stillThere = enemies.indexOf(target)!==-1;
        if(!stillThere){ autoChase=false; target=null; }
        if(target){
          if(chebyshev(player,target)!==1 && pathQueue.length===0){
            const pAdj=bfsToAdjacencySmart(player.x,player.y,target.x,target.y,target.type);
            if(pAdj && pAdj.length) pathQueue=pAdj;
          }
          if(chebyshev(player,target)===1){
            const nowA=performance.now(); if(nowA-player.lastAtk>=getAtkCd()) attackEnemy(target);
          }
        }
      }

      updateDmgTexts(dt);
      if(destMarker){ destMarker.ttl-=dt; if(destMarker.ttl<=0) destMarker=null; }

      updateTweens();
      draw();

    }catch(e){ panic('step', e); }
  }
  function tryStepAlongPath(e, now){
    if(!e.path || !e.path.length) return;
    const nxt=e.path.shift();
    if(!walkable(nxt.x,nxt.y)) { e.path=[]; return; }
    for(let k=0;k<enemies.length;k++){ const other=enemies[k]; if(other!==e && other.x===nxt.x && other.y===nxt.y){ e.path=[]; return; } }
    if(nxt.x===player.x && nxt.y===player.y){ e.path=[]; return; }
    const fx=e.x, fy=e.y; e.x=nxt.x; e.y=nxt.y; startTween(e,fx,fy,e.x,e.y,now);
  }

  /* Character panel */
  function pct(v){ return Math.round((v||0)*100); }
  function renderCharPanel(){
    if(charWin.classList.contains('hidden')) return;
    const need=(player.lvl<MAX_LVL)?xpNeeded(player.lvl):1;
    const basics=[
      ['Livello','LV '+player.lvl],
      ['XP',''+player.exp+' / '+(player.lvl<MAX_LVL?need:'‚Äî')],
      ['HP',''+player.hp+' / '+player.maxHp],
      ['Attacco',''+player.atkMin+'‚Äì'+player.atkMax],
      ['Crit Chance', pct(getCritChance())+'%'],
      ['Crit Damage', pct(player.stats.critDmg||0)+'%'],
      ['CD Attacco', getAtkCd()+' ms']
    ];
    const stats=[
      ['Difesa (flat)', (player.stats.defense|0)],
      ['Mitigazione', pct(clamp(player.stats.mitigation||0,0,0.60))+'%'],
      ['Res. Proiettili', pct(clamp(player.stats.projRes||0,0,0.60))+'%'],
      ['Res. Bleed', pct(clamp(player.stats.bleedRes||0,0,0.70))+'%'],
      ['Vel. Attacco', pct(clamp(player.stats.atkSpeed||0,0,0.50))+'%'],
      ['Luck (Crit +)', pct(player.stats.luck||0)+'%']
    ];
    charBasics.innerHTML=basics.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
    charStats.innerHTML =stats.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
  }
  function renderCharIfOpen(){ renderCharPanel(); }

  /* Save/Load/Reset */
  btnSave.onclick=()=>{
    try{
      localStorage.setItem(SAVE_KEY, JSON.stringify({map, player, enemies, world:WORLD.current}));
      toast('Salvato');
    }catch(e){ panic('save', e); }
  };
  btnLoad.onclick=()=>{
    try{
      const raw=localStorage.getItem(SAVE_KEY); if(!raw) return alert('Nessun salvataggio.');
      const d=JSON.parse(raw);
      if(d && d.map && d.map.length===ROWS){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) map[y][x]=d.map[y][x]|0; }
      if(d && d.player){ for(const k in d.player){ if(d.player.hasOwnProperty(k)) player[k]=d.player[k]; } }
      enemies.length=0; if(d && Array.isArray(d.enemies)){ for(let i=0;i<d.enemies.length;i++) enemies.push(d.enemies[i]); }
      if(d && d.world){ WORLD.current=d.world; applyTheme(WORLD.current==='main'?THEMES.main:THEMES.spawn); }
      setPlayerPos(player.x,player.y); pathQueue.length=0; dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
      recomputeStats(false); draw(); renderCharIfOpen(); toast('Caricato');
    }catch(e){ panic('load', e); }
  };
  btnReset.onclick=()=>location.reload();

  /* Kick loop */
  setInterval(step, 120);
  (function anim(){ updateTweens(); draw(); requestAnimationFrame(anim); })();

})();
</script>
</body>
</html>
