<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Drakoria ‚Äî OneFile (HUD-6)</title>
<style>
:root{
  --bg:#0b1224; --panel:#0f172a; --stroke:#1f2a44; --text:#e5e7eb; --muted:#9ca3af;
  --tileA:#0e2a1e; --tileB:#123022; --block:#15223b;
  --player:#3b82f6; --enemy:#ef4444; --coin:#facc15; --shadow:#0006; --hpBack:#1f2937;
  --accent:#7c3aed; --rare:#60a5fa; --epic:#a78bfa; --legend:#f59e0b;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--stroke)}
header .muted{color:var(--muted);margin-left:8px}
header .btn{background:#26325a;color:#fff;border:1px solid #31406e;border-radius:8px;padding:6px 10px;cursor:pointer}
main{max-width:1400px;margin:14px auto;padding:12px;background:var(--panel);border:1px solid var(--stroke);border-radius:12px;position:relative}
#game{display:block;width:100%;height:auto;border-radius:10px;border:1px solid var(--stroke);background:#0a1630;image-rendering:pixelated;touch-action:none}
.help{margin:.6rem 0 0;color:#a1a1aa}
#status{margin-top:8px;color:var(--muted)}
.err{position:fixed;left:50%;top:70px;transform:translateX(-50%);background:#7f1d1d;color:#fff;border:1px solid #fecaca;border-radius:8px;padding:8px 12px;z-index:50;font-weight:600;max-width:90vw;white-space:pre-wrap;display:none}

/* Log compatto (opzionale) */
.log{position:fixed; left:16px; bottom:16px; width:300px; max-width:80vw;
  background:rgba(15,23,42,.9); border:1px solid #1f2a44; border-radius:10px; padding:8px 10px; z-index:26}
.log .h{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-weight:700}
.log .b{max-height:160px; overflow:auto; font:12px/1.3 system-ui}
.log .line{margin:2px 0}
.log .dmg{color:#fca5a5}
.log .heal{color:#86efac}
.log .loot{color:#fde68a}
.log .sys{color:#93c5fd}

/* Overlay Game Over */
.death{position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:60}
.death.hidden{display:none}
.death-box{background:#0f172a; border:1px solid #1f2a44; padding:14px; border-radius:12px; width:min(420px,92vw); box-shadow:0 18px 44px rgba(0,0,0,.55)}
.death-title{font-weight:800; font-size:18px; margin-bottom:8px}
.death-sub{color:#cbd5e1; margin-bottom:12px}
.death-actions{display:flex; gap:8px; justify-content:flex-end}
.btn{border:1px solid #31406e;background:#2563eb;color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
.btn:disabled{background:#1f2a44;color:#9aa0ad;cursor:not-allowed}
</style>
</head>
<body>
<header>
  <div><strong>Drakoria</strong> <span class="muted">one-file build</span></div>
  <div>
    <button id="btnSave" class="btn">Save</button>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnReset" class="btn">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="1344" height="768" aria-label="Gioco"></canvas>
  <p class="help">
    Tap per muoverti ‚Ä¢ tap su un <b>nemico</b> per selezionarlo ‚Ä¢ <b>doppio tap</b> per auto-inseguire ‚Ä¢ SPAZIO/üó°Ô∏è attacca.
    Portale viola ‚Üí mondo <b>Main</b> (nemici). La mini-mappa rotonda in alto a sinistra √® sempre attiva.  
  </p>
  <div id="status"></div>
</main>

<!-- Combat Log -->
<section class="log" id="logPanel">
  <div class="h"><span>Log</span></div>
  <div id="logBody" class="b"></div>
</section>

<div id="errBox" class="err"></div>

<!-- Overlay Game Over -->
<div id="deathOverlay" class="death hidden" role="dialog" aria-modal="true" aria-label="Game Over">
  <div class="death-box">
    <div class="death-title">Sei morto</div>
    <div class="death-sub">Scegli <b>Respawn</b> per tornare allo spawn con vita piena, oppure <b>Reset</b> per ricaricare il gioco.</div>
    <div class="death-actions">
      <button id="deathRespawn" class="btn">Respawn</button>
      <button id="deathReset" class="btn">Reset</button>
    </div>
  </div>
</div>

<script>
/* ===== Drakoria ‚Äî ONE FILE BUILD (HUD-6) ===== */
(function(){
  var BUILD='HUD-6';
  var SAVE_KEY='save_of_hud6';
  var cv=document.getElementById('game'); var ctx=cv.getContext('2d');

  /* --- UI refs --- */
  var statusEl=document.getElementById('status');
  var btnSave=document.getElementById('btnSave'), btnLoad=document.getElementById('btnLoad'), btnReset=document.getElementById('btnReset');
  var errBox=document.getElementById('errBox');
  var logBody=document.getElementById('logBody');
  var deathOverlay=document.getElementById('deathOverlay');
  var deathRespawn=document.getElementById('deathRespawn');
  var deathReset=document.getElementById('deathReset');

  function panic(where, e){
    errBox.style.display='block';
    errBox.textContent='ERRORE '+where+': '+(e && (e.message||e));
    if(window.console&&console.error) console.error('[PANIC]', where, e);
  }
  function toast(msg){ statusEl.textContent='['+BUILD+'] '+msg; }

  /* --- World constants --- */
  var COLS=21, ROWS=12, TILE=64;
  cv.width  = COLS*TILE;
  cv.height = ROWS*TILE;

  var WORLD = { current:'spawn', portals: makePortals() };
  var worldInited = { spawn:false, main:false };

  function makePortals(){
    var mid = Math.floor(ROWS/2);
    return {
      main:  [ { x: 1,        y: mid, to: 'spawn', tx: COLS-2, ty: mid } ],
      spawn: [ { x: COLS-2,   y: mid, to: 'main',  tx: 1,      ty: mid } ]
    };
  }
  function isPortalTile(worldName,x,y){
    var list = (WORLD.portals && WORLD.portals[worldName]) || [];
    for (var i=0;i<list.length;i++){ var p=list[i]; if(p.x===x && p.y===y) return true; }
    return false;
  }

  var THEMES = {
    main:  { '--tileA':'#0e2a1e', '--tileB':'#123022' },
    spawn: { '--tileA':'#1e1f3a', '--tileB':'#23264a' }
  };
  function applyTheme(vars){
    var root = document.documentElement.style;
    for (var k in vars) root.setProperty(k, vars[k]);
  }

  function buildMap(name){
    var cols=COLS, rows=ROWS, m=[];
    for (var y=0;y<rows;y++){ var row=[]; for (var x=0;x<cols;x++) row.push(0); m.push(row); }
    if (name==='main'){
      // qualche blocco a caso:
      for (var i=0;i<16;i++){
        var bx=(Math.random()*cols|0), by=(Math.random()*rows|0);
        if (isPortalTile('main', bx, by)) continue;
        if ((bx===1 && by===4) || (bx===cols-2 && by===rows-2)) continue;
        m[by][bx]=1;
      }
    }
    return { map:m, themeVars:(name==='main')?THEMES.main:THEMES.spawn };
  }

  /* --- Game state --- */
  var map=[];
  var player={
    x:12,y:4,
    baseMaxHp:100, baseAtkMin:6, baseAtkMax:12,
    maxHp:100, hp:100, atkMin:6, atkMax:12,
    coins:0,pots:1,lastAtk:0,atkCd:450,lvl:1,exp:0,
    critChance:0.10, critMult:1.5
  };
  var _eid=1; function giveId(e){ e.id=_eid++; return e; }
  function makeSlime(x,y){
    var e={ kind:'slime', type:'melee', x:x,y:y, spawnX:x,spawnY:y,
      hp:60,maxHp:60, atkMin:5,atkMax:9, hitCd:800,lastHit:0,
      aggro:false, aggroRange:5, leashRange:15, loseAggroMs:6000, lastSeenTs:0,
      moveTick:0, moveEvery:6, path:[], mode:'idle'
    };
    e.vx=x; e.vy=y; return giveId(e);
  }
  function makeArcher(x,y){
    var e={ kind:'archer', type:'ranged', x:x,y:y, spawnX:x,spawnY:y,
      hp:40,maxHp:40, atkCd:1200,lastShot:0, rangeMin:3, rangeMax:7, pokeCd:700,lastPoke:0,
      aggro:false, aggroRange:7, leashRange:15, loseAggroMs:6000, lastSeenTs:0,
      moveTick:0, moveEvery:6, path:[], mode:'idle'
    };
    e.vx=x; e.vy=y; return giveId(e);
  }

  // === NUOVO: gruppi in pattuglia ===
  var _grpId=1;
  function createPatrolGroup(type, count, anchorX, anchorY, radius){
    var id='g'+(_grpId++), made=[];
    for (var i=0;i<count;i++){
      var pos=findFreeNear(anchorX,anchorY,radius||2,30);
      var e=(type==='ranged')?makeArcher(pos.x,pos.y):makeSlime(pos.x,pos.y);
      e.groupId=id;
      e.groupAnchor={x:anchorX,y:anchorY};
      e.patrolRadius=Math.max(1,(radius|0)||2);
      e.spawnX=e.x; e.spawnY=e.y;
      e.moveEvery=e.moveEvery||6;
      enemies.push(e); made.push(e);
    }
    return made;
  }
  function findFreeNear(cx,cy,r,tries){
    tries=tries||25;
    for (var k=0;k<tries;k++){
      var nx=Math.max(0,Math.min(COLS-1,cx+rndInt(-r,r)));
      var ny=Math.max(0,Math.min(ROWS-1,cy+rndInt(-r,r)));
      if (walkable(nx,ny) && tileFree(nx,ny) && !isPortalTile(WORLD.current,nx,ny)){
        return {x:nx,y:ny};
      }
    }
    return randEmpty();
  }

  var enemies=[], coins=[], potions=[], projectiles=[], lootBags=[];
  var BAG_TTL_MS=90000, BAG_WARN_MS=10000;

  // Init su spawn (vuoto apposta)
  ;(function init(){
    var res=buildMap('spawn');
    map=res.map; applyTheme(res.themeVars);
    WORLD.current='spawn'; worldInited.spawn=true;
    enemies.length=0; // nessun nemico nello spawn
  })();

  /* --- Utils --- */
  function inside(x,y){ return x>=0&&y>=0&&x<COLS&&y<ROWS; }
  function rndInt(a,b){ return a+((Math.random()*(b-a+1))|0); }
  function chebyshev(a,b){ var dx=Math.abs(a.x-b.x), dy=Math.abs(a.y-b.y); return dx>dy?dx:dy; }
  function walkable(x,y){ if(!inside(x,y)) return false; if(map[y][x]===1) return false; return true; }
  function tileFree(x,y){
    if(map[y][x]!==0) return false;
    if(x===player.x && y===player.y) return false;
    for(var i=0;i<enemies.length;i++) if(enemies[i].x===x && enemies[i].y===y) return false;
    return true;
  }
  function getVar(n){ var cs=window.getComputedStyle(document.documentElement); return cs.getPropertyValue(n).trim(); }

  /* --- BFS path --- */
  function bfs(sx,sy,tx,ty){
    if(!walkable(tx,ty)) return null;
    var q=[{x:sx,y:sy}], head=0, prev={}, seen={}; seen[sx+','+sy]=1;
    var dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(head<q.length){
      var c=q[head++]; if(c.x===tx && c.y===ty){
        var path=[], key=tx+','+ty;
        while(prev[key]){ var s=key.split(','); path.push({x:+s[0],y:+s[1]}); key=prev[key].x+','+prev[key].y; }
        path.reverse(); return path;
      }
      for(var d=0; d<4; d++){
        var nx=c.x+dirs[d][0], ny=c.y+dirs[d][1], kk=nx+','+ny;
        if(!walkable(nx,ny) || seen[kk]) continue; seen[kk]=1; prev[kk]={x:c.x,y:c.y}; q.push({x:nx,y:ny});
      }
    } return null;
  }
  function bfsToAdjacencySmart(sx,sy,tx,ty,etype){
    var opts=[[tx+1,ty],[tx-1,ty],[tx,ty+1],[tx,ty-1]], best=null, bestScore=1e9;
    for(var i=0;i<opts.length;i++){
      var ax=opts[i][0], ay=opts[i][1]; if(!walkable(ax,ay)) continue;
      var occupied=false; for(var j=0;j<enemies.length;j++){ var e=enemies[j]; if(e.x===ax&&e.y===ay){ occupied=true; break; } }
      if(occupied) continue;
      var p=bfs(sx,sy,ax,ay); if(!p) continue; var score=p.length; if(etype==='ranged'&&(ax===tx||ay===ty)) score+=2;
      if(score<bestScore){ bestScore=score; best=p; }
    } return best;
  }

  /* --- Tweening (smooth) --- */
  var MOVE_MS=110;
  function startTween(o, fx, fy, tx, ty, now){ o.vFromX=fx; o.vFromY=fy; o.vToX=tx; o.vToY=ty; o.vStart=now; o.vEnd=now+MOVE_MS; if(o.vx==null)o.vx=fx; if(o.vy==null)o.vy=fy; }
  function tweenUpdate(o, now){
    if(!o) return;
    var has=(o.vStart && o.vEnd && o.vEnd>o.vStart);
    if(has && now<o.vEnd){
      var t=(now-o.vStart)/(o.vEnd-o.vStart); t=t*t*(3-2*t);
      o.vx=o.vFromX+(o.vToX-o.vFromX)*t; o.vy=o.vFromY+(o.vToY-o.vFromY)*t;
    } else {
      if(o.x!=null) o.vx=o.x; if(o.y!=null) o.vy=o.y; o.vStart=0; o.vEnd=0;
    }
  }
  function updateTweens(){
    var now=performance.now();
    tweenUpdate(player, now);
    for(var i=0;i<enemies.length;i++) tweenUpdate(enemies[i], now);
    for(var j=0;j<projectiles.length;j++) tweenUpdate(projectiles[j], now);
  }

  /* --- Input --- */
  var target=null, autoChase=false, lastEnemyTapTs=0, lastEnemyTapId=-1;
  var pathQueue=[];
  function canvasToTile(ev){
    var r=cv.getBoundingClientRect(), t=ev.touches&&ev.touches[0];
    var cx=t?t.clientX:ev.clientX, cy=t?t.clientY:ev.clientY;
    var sx=(cx-r.left)*(cv.width/r.width), sy=(cy-r.top)*(cv.height/r.height);
    var tx=Math.max(0,Math.min(COLS-1,(sx/TILE)|0)), ty=Math.max(0,Math.min(ROWS-1,(sy/TILE)|0));
    return {sx:sx, sy:sy, tx:tx, ty:ty};
  }
  function enemyRect(e){ var x=e.x*TILE+TILE/2-16, y=e.y*TILE+TILE/2-22; return {x:x,y:y,w:32,h:36}; }
  function inRect(px,py,r){ return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h; }

  function onCanvasTap(ev){
    try{
      if(dead) return;
      ev.preventDefault();
      var m=canvasToTile(ev), now=performance.now();

      // targeting via hitbox del ‚Äúcorpo‚Äù (rettangolo)
      var clicked=null;
      for(var i=0;i<enemies.length;i++){ var ee=enemies[i]; if(inRect(m.sx,m.sy,enemyRect(ee))){ clicked=ee; break; } }
      if(clicked){
        if(lastEnemyTapId===clicked.id && (now-lastEnemyTapTs)<=350){ target=clicked; autoChase=true; pathQueue=[]; }
        else { target=clicked; autoChase=false; }
        lastEnemyTapId=clicked.id; lastEnemyTapTs=now; updateTargetFrame(); draw(); return;
      }

      // movement
      autoChase=false;
      var p=bfs(player.x,player.y,m.tx,m.ty);
      if(p&&p.length){ pathQueue=p; } else {
        var dx=Math.sign(m.tx-player.x), dy=Math.sign(m.ty-player.y);
        var tryFirst=(Math.abs(m.tx-player.x)>=Math.abs(m.ty-player.y))
          ? [{x:player.x+dx,y:player.y},{x:player.x,y:player.y+dy}]
          : [{x:player.x,y:player.y+dy},{x:player.x+dx,y:player.y}];
        var stepped=false;
        for(var k=0;k<tryFirst.length;k++){
          var nxt=tryFirst[k];
          if(inside(nxt.x,nxt.y)&&walkable(nxt.x,nxt.y)){ pathQueue=[nxt]; stepped=true; break; }
        }
        if(!stepped) toast('Nessun percorso');
      }

      // attacco se adiacente e pronto
      if(target && chebyshev(player,target)===1 && (now-player.lastAtk)>=player.atkCd){ attackEnemy(target); return; }

      draw(); updateTargetFrame();
    }catch(e){ panic('input', e); }
  }
  cv.addEventListener('pointerup', onCanvasTap, {passive:false});
  cv.addEventListener('click', onCanvasTap, false);
  window.addEventListener('keydown', function(e){ if(e.code==='Space'||e.key===' ') tryAttackAdjacent(); }, false);

  function tryAttackAdjacent(){
    var now=performance.now(); if(now-player.lastAtk<player.atkCd) return false;
    if(target && chebyshev(player,target)===1){ attackEnemy(target); return true; }
    for(var i=0;i<enemies.length;i++){ var en=enemies[i]; if(chebyshev(player,en)===1){ attackEnemy(en); return true; } }
    return false;
  }

  /* --- Combat + DPS + Floaty dmg --- */
  var dmgTexts=[]; var dpsEvents=[], dpsPeak=0;
  function addDmgText(tx,ty,txt,color){ var px=tx*TILE+TILE/2, py=ty*TILE+TILE/2-28; dmgTexts.push({x:px,y:py,txt:txt,color:color,ttl:700,vy:-0.04}); }
  function updateDmgTexts(dt){ for(var i=dmgTexts.length-1;i>=0;i--){ var d=dmgTexts[i]; d.ttl-=dt; d.y+=d.vy*dt; if(d.ttl<=0) dmgTexts.splice(i,1); } }
  function drawDmgTexts(){ for(var i=0;i<dmgTexts.length;i++){ var d=dmgTexts[i]; var a=Math.max(0,Math.min(1,d.ttl/700)); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=d.color; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(d.txt,d.x,d.y); ctx.restore(); } }
  function recordDPS(amount){
    var now=performance.now(); dpsEvents.push({t:now,a:amount|0});
    var cutoff=now-10000; while(dpsEvents.length && dpsEvents[0].t<cutoff) dpsEvents.shift();
    var sum=0; for(var i=0;i<dpsEvents.length;i++) sum+=dpsEvents[i].a; var dps=Math.round(sum/10); if(dps>dpsPeak) dpsPeak=dps;
  }

  function rollCrit(ch){ return Math.random()<(ch||0); }
  function rndAtk(min,max,critChance,critMult){
    var base=rndInt(min,max), isCrit=rollCrit(critChance), dmg=Math.floor(base*(isCrit?(critMult||1.5):1));
    return {dmg:dmg, isCrit:isCrit};
  }

  function attackEnemy(t){
    var now=performance.now(); player.lastAtk=now;
    var a=rndAtk(player.atkMin,player.atkMax,player.critChance,player.critMult);
    t.hp=Math.max(0,t.hp-a.dmg);
    addDmgText(t.x,t.y,(a.isCrit?'CRIT ':'-')+a.dmg, a.isCrit?'#facc15':'#ffd166');
    flashCircle(t.x,t.y, a.isCrit?'#ffd166':'#ff0000', a.isCrit?0.35:0.25, a.isCrit?30:26);
    t.aggro=true; t.lastSeenTs=now;
    recordDPS(a.dmg); logDmg('Colpisci '+nameOf(t)+' per '+a.dmg+(a.isCrit?' (critico)':'')+'.');
    updateTargetFrame();
    if(t.hp===0){
      if(target===t){ target=null; autoChase=false; hideTargetFrame(); }
      trySpawnLootBag(t.x,t.y, t.kind||t.type);
      logSys(nameOf(t)+' √® stato sconfitto.');
      enemies.splice(enemies.indexOf(t),1);
    }
  }
  function takePlayerDamage(amount, label){
    player.hp=Math.max(0, player.hp-amount);
    addDmgText(player.x,player.y,label+amount,'#ff6b6b');
    flashCircle(player.x,player.y,'#ff0000',0.25,26);
    logDmg('Subisci '+amount+' danni.');
    if(player.hp===0) gameOver();
  }

  /* --- Loot --- */
  var nextItemId=1;
  function trySpawnLootBag(x,y,kind){
    var items=[];
    if(Math.random()<0.85) items.push(makeItem('Monete','ü™ô','common','coin', rndInt(1,3)));
    if(Math.random()<0.35) items.push(makeItem('Pozione','üçµ','common','potion',1,{heal:35}));
    if(items.length===0) return;
    lootBags.push({ x:x, y:y, items:items, createdAt:performance.now(), ttlMs:BAG_TTL_MS });
  }
  function makeItem(name,icon,rarity,type,qty,extra){ var o={ id:nextItemId++, name:name, icon:icon, rarity:rarity, type:type, qty:qty||1 }; if(extra&&typeof extra==='object'){ for(var k in extra)o[k]=extra[k]; } return o; }

  /* --- Target frame (semplice in status) --- */
  function capFirst(s){ return s ? s.charAt(0).toUpperCase()+s.slice(1) : ''; }
  function nameOf(t){ return t && (t.kind ? capFirst(t.kind) : (t.type==='ranged'?'Arciere':'Mostro')); }
  function updateTargetFrame(){
    if(!target || enemies.indexOf(target)===-1){ hideTargetFrame(); return; }
    var ratio=Math.max(0,Math.min(1,target.hp/target.maxHp));
    toast('Target: '+nameOf(target)+' HP '+target.hp+'/'+target.maxHp+' ('+Math.round(ratio*100)+'%)');
  }
  function hideTargetFrame(){ /* no-op, lasciamo lo status libero */ }

  /* --- Save/Load --- */
  btnSave.onclick=function(){
    try{
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        map:map, player:player, enemies:enemies, coins:coins, potions:potions, projectiles:projectiles,
        lootBags:lootBags, world:WORLD.current, worldInited:worldInited
      }));
      toast('Salvato.');
    }catch(e){ panic('save', e); }
  };
  btnLoad.onclick=function(){
    try{
      var raw=localStorage.getItem(SAVE_KEY); if(!raw) return alert('Nessun salvataggio.');
      var d=JSON.parse(raw), i,y,x;
      if(d && d.map && d.map.length===ROWS){ for(y=0;y<ROWS;y++) for(x=0;x<COLS;x++) map[y][x]=d.map[y][x]|0; }
      if(d && d.player){ for(var k in d.player){ if(d.player.hasOwnProperty(k)) player[k]=d.player[k]; } }
      enemies.length=0; if(d && d.enemies) for(i=0;i<d.enemies.length;i++) enemies.push(d.enemies[i]);
      coins.length=0; if(d && d.coins) for(i=0;i<d.coins.length;i++) coins.push(d.coins[i]);
      potions.length=0; if(d && d.potions) for(i=0;i<d.potions.length;i++) potions.push(d.potions[i]);
      projectiles.length=0; if(d && d.projectiles) for(i=0;i<d.projectiles.length;i++) projectiles.push(d.projectiles[i]);
      lootBags.length=0; if(d && d.lootBags) for(i=0;i<d.lootBags.length;i++) lootBags.push(d.lootBags[i]);
      if(d && d.world){ WORLD.current=d.world; applyTheme(WORLD.current==='main'?THEMES.main:THEMES.spawn); }
      if(d && d.worldInited){ worldInited=d.worldInited; }
      toast('Caricato.');
      dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
    }catch(e){ panic('load', e); }
  };
  btnReset.onclick=function(){ location.reload(); };

  /* --- Enemy patrol & AI helpers --- */
  function tryStepAlongPath(e){
    if(!e.path || !e.path.length) return;
    var nxt=e.path.shift();
    if(!walkable(nxt.x,nxt.y)) { e.path=[]; return; }
    for(var k=0;k<enemies.length;k++){ var other=enemies[k]; if(other!==e && other.x===nxt.x && other.y===nxt.y){ e.path=[]; return; } }
    if(nxt.x===player.x && nxt.y===player.y){ e.path=[]; return; }
    var fx=e.x, fy=e.y; e.x=nxt.x; e.y=nxt.y; startTween(e, fx, fy, e.x, e.y, performance.now());
  }

  /* --- Mini-mappa overlay nel canvas (rotonda) --- */
  function drawMiniOverlay(){
    var size=120, pad=10, rad=size/2, cx=pad+rad, cy=pad+rad;
    ctx.save();
    ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.closePath(); ctx.clip();
    // fondo
    ctx.fillStyle='rgba(15,23,42,.85)'; ctx.fillRect(cx-rad,cy-rad,size,size);

    var cw=size, ch=size, cellW=cw/COLS, cellH=ch/ROWS, ox=cx-rad, oy=cy-rad;
    for(var y=0;y<ROWS;y++) for(var x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?'#2b3b66':'#164e24';
      ctx.fillRect(ox+x*cellW, oy+y*cellH, cellW, cellH);
    }
    // loot / oggetti semplici (puntini)
    ctx.fillStyle='#facc15';
    for(var i=0;i<coins.length;i++){ var c=coins[i]; ctx.fillRect(ox+c.x*cellW+1, oy+c.y*cellH+1, 2,2); }
    ctx.fillStyle='#a78bfa';
    for(var p=0;p<potions.length;p++){ var po=potions[p]; ctx.fillRect(ox+po.x*cellW+1, oy+po.y*cellH+1, 2,2); }
    for(var eI=0;eI<enemies.length;eI++){ var en=enemies[eI]; ctx.fillStyle=(en.type==='ranged')?'#a855f7':'#ef4444';
      ctx.fillRect(ox+en.x*cellW+1, oy+en.y*cellH+1, 3,3); }
    ctx.fillStyle='#3b82f6'; ctx.fillRect(ox+player.x*cellW+1, oy+player.y*cellH+1, 3,3);

    // bordo
    ctx.restore();
    ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.strokeStyle='#1f2a44'; ctx.lineWidth=2; ctx.stroke();
  }

  /* --- Portali + cambio mappa --- */
  var teleportGuardUntil=0;
  function findSafeExit(worldName, px, py){
    var cand=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1],[2,0],[-2,0],[0,2],[0,-2]];
    for (var i=0;i<cand.length;i++){
      var nx=px+cand[i][0], ny=py+cand[i][1];
      if(!inside(nx,ny)) continue;
      if(!walkable(nx,ny)) continue;
      if(isPortalTile(worldName,nx,ny)) continue;
      if(!tileFree(nx,ny)) continue;
      return {x:nx, y:ny};
    }
    return {x:px,y:py};
  }
  function onEnterWorld(name){
    if(name==='main' && !worldInited.main){
      // genera pattuglie
      createPatrolGroup('melee', 3, COLS-5, ROWS-4, 2);
      enemies.push(makeArcher(COLS-4,2));
      worldInited.main=true;
      logSys('Nemici generati in Main.');
    }
    if(name==='spawn' && !worldInited.spawn){
      worldInited.spawn=true;
    }
  }
  function checkPortalAndTeleport(justEntered){
    if(!justEntered) return;
    var now=performance.now(); if(now<teleportGuardUntil) return;
    var px=player.x, py=player.y, list=WORLD.portals[WORLD.current]||[], hit=null;
    for(var i=0;i<list.length;i++){ var p=list[i]; if(p.x===px && p.y===py){ hit=p; break; } }
    if(!hit) return;

    var res=buildMap(hit.to); map=res.map; applyTheme(res.themeVars); WORLD.current=hit.to;
    var exit=findSafeExit(hit.to, hit.tx, hit.ty); player.x=exit.x; player.y=exit.y; player.vx=player.x; player.vy=player.y;

    // pulizia leggera quando si torna allo spawn
    if(WORLD.current==='spawn'){ coins.length=0; potions.length=0; projectiles.length=0; }

    onEnterWorld(WORLD.current);
    pathQueue.length=0; teleportGuardUntil=performance.now()+450;
    logSys('Teletrasporto: '+(WORLD.current==='spawn'?'Spawn':'Main'));
  }

  /* --- Step loop (120ms) --- */
  var lastPlayerX=player.x, lastPlayerY=player.y;
  function step(){
    try{
      // Auto-chase + auto-attack
      if(autoChase && target){
        var still=enemies.indexOf(target)!==-1;
        if(!still){ autoChase=false; target=null; hideTargetFrame(); }
        if(target){
          if(chebyshev(player,target)!==1 && pathQueue.length===0){
            var pAdj=bfsToAdjacencySmart(player.x,player.y,target.x,target.y,target.type);
            if(pAdj&&pAdj.length) pathQueue=pAdj;
          }
          var nowA=performance.now(); if(chebyshev(player,target)===1 && (nowA-player.lastAtk)>=player.atkCd) attackEnemy(target);
        }
      }

      // Player step
      if(pathQueue.length){
        var next=pathQueue.shift();
        var blocked=false;
        if(!walkable(next.x,next.y)) blocked=true;
        for(var i=0;i<enemies.length;i++) if(enemies[i].x===next.x&&enemies[i].y===next.y){ blocked=true; break; }
        if(!blocked){
          var fx=player.x, fy=player.y; player.x=next.x; player.y=next.y; startTween(player, fx, fy, player.x, player.y, performance.now());
        } else pathQueue=[];
      }

      var justEntered = (player.x!==lastPlayerX || player.y!==lastPlayerY);
      checkPortalAndTeleport(justEntered);
      lastPlayerX=player.x; lastPlayerY=player.y;

      // Enemy AI (patrol ‚Üí aggro ‚Üí return)
      var now=performance.now();
      for(var j=0;j<enemies.length;j++){
        var e=enemies[j];
        var distC=chebyshev(e,player);
        if(!e.aggro && distC<=e.aggroRange){ e.aggro=true; e.lastSeenTs=now; }

        var tooFar = chebyshev({x:e.spawnX,y:e.spawnY}, player) > e.leashRange || distC > e.leashRange;
        if(e.aggro){
          // refresh visione
          if(distC<=1) e.lastSeenTs=now;
          if(tooFar || (now-e.lastSeenTs)>e.loseAggroMs){
            e.aggro=false; e.path=bfs(e.x,e.y,e.spawnX,e.spawnY)||[]; e.mode='return';
          }
        }

        e.moveTick=(e.moveTick+1)%e.moveEvery;
        var canMove=(e.moveTick===0);

        if(e.aggro){
          if(e.type==='melee'){
            if(canMove){
              if(chebyshev(e,player)>1){
                e.path=bfsToAdjacencySmart(e.x,e.y,player.x,player.y,'melee')||e.path||[];
              }
              tryStepAlongPath(e);
            }
            var near=(Math.abs(e.x-player.x)+Math.abs(e.y-player.y))<=1;
            if(near && (now-e.lastHit)>=e.hitCd){
              e.lastHit=now; var a=rndAtk(e.atkMin,e.atkMax,0.05,1.5); takePlayerDamage(a.dmg, a.isCrit?'CRIT -':'-');
            }
          } else { // ranged
            var distM=Math.abs(e.x-player.x)+Math.abs(e.y-player.y);
            var inRange=(distM>=e.rangeMin && distM<=e.rangeMax && (e.x===player.x || e.y===player.y));
            if(inRange){
              if(now-e.lastShot>=e.atkCd){
                e.lastShot=now; var dx2=0,dy2=0;
                if(e.x===player.x) dy2=player.y>e.y?1:-1; else if(e.y===player.y) dx2=player.x>e.x?1:-1;
                if(dx2||dy2) projectiles.push({x:e.x,y:e.y,dx:dx2,dy:dy2,spdTick:0,dmg:rndInt(6,10), vx:e.x, vy:e.y, vStart:0, vEnd:0});
              }
              if(distM<e.rangeMin && canMove){
                var backX=e.x + (player.x<e.x?1:(player.x>e.x?-1:0));
                var backY=e.y + (player.y<e.y?1:(player.y>e.y?-1:0));
                if(walkable(backX,backY) && !(backX===player.x&&backY===player.y)){ var fx=e.x,fy=e.y; e.x=backX; e.y=backY; startTween(e,fx,fy,e.x,e.y,performance.now()); }
              }
              var adj=(Math.max(Math.abs(e.x-player.x),Math.abs(e.y-player.y))===1);
              if(adj && (now-e.lastPoke)>=e.pokeCd){ e.lastPoke=now; var a2=rndAtk(4,7,0.05,1.5); takePlayerDamage(a2.dmg, a2.isCrit?'CRIT -':'-'); }
            } else if(canMove){
              // avvicinati in LOS grossolana
              var pth=bfsToAdjacencySmart(e.x,e.y,player.x,player.y,'ranged') || bfs(e.x,e.y,player.x,player.y);
              if(pth && pth.length>2) pth.length=2;
              e.path=pth||e.path||[]; tryStepAlongPath(e);
            }
          }
        } else {
          // PATROL semplice: quando idle, ogni tanto muovi verso un punto casuale vicino all'anchor
          if((e.x!==e.spawnX || e.y!==e.spawnY) && e.mode==='return'){
            if(canMove){ if(!e.path || !e.path.length) e.path=bfs(e.x,e.y,e.spawnX,e.spawnY)||[]; tryStepAlongPath(e); }
          } else {
            e.mode='idle';
            if(canMove){
              var anchor=(e.groupAnchor || {x:e.spawnX, y:e.spawnY});
              var dest=findFreeNear(anchor.x, anchor.y, e.patrolRadius||2, 10);
              e.path=bfs(e.x,e.y,dest.x,dest.y)||[]; tryStepAlongPath(e);
            }
          }
        }
      }

      // Proiettili
      for(var pi=projectiles.length-1; pi>=0; pi--){
        var pr=projectiles[pi];
        pr.spdTick=(pr.spdTick+1)%2; if(pr.spdTick!==0) continue;
        var nx=pr.x+pr.dx, ny=pr.y+pr.dy;
        if(!inside(nx,ny) || map[ny][nx]===1){ projectiles.splice(pi,1); continue; }
        if(nx===player.x && ny===player.y){
          var a3=rndAtk(pr.dmg,pr.dmg,0.05,1.5); takePlayerDamage(a3.dmg, a3.isCrit?'CRIT -':'-');
          projectiles.splice(pi,1); continue;
        }
        startTween(pr, pr.x, pr.y, nx, ny, performance.now()); pr.x=nx; pr.y=ny;
      }

      // Pickup magnet semplice
      for(var c=coins.length-1;c>=0;c--){ if(chebyshev(coins[c],player)<=1){ coins.splice(c,1); player.coins++; logLoot('Moneta +1'); } }
      for(var p=potions.length-1;p>=0;p--){ if(chebyshev(potions[p],player)<=1){ potions.splice(p,1); player.pots++; logLoot('Pozione +1'); } }

      // Decadimento sacchetti (solo rendering, non UI di raccolta manuale per semplicit√†)
      var nowt=performance.now();
      for(var lb=lootBags.length-1; lb>=0; lb--){
        var b=lootBags[lb]; var remain=b.ttlMs-(nowt-b.createdAt); if(remain<=0){ lootBags.splice(lb,1); }
      }

    }catch(e){ panic('step', e); }
  }

  /* --- Anim loop --- */
  var lastFrameTs=performance.now();
  (function anim(){
    updateTweens();
    var now=performance.now(), dt=now-lastFrameTs; lastFrameTs=now;
    updateDmgTexts(dt);
    draw();
    requestAnimationFrame(anim);
  })();
  setInterval(step,120);

  /* --- Draw --- */
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    var x,y;
    for(y=0;y<ROWS;y++) for(x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?getVar('--block'):(((x+y)%2===0)?getVar('--tileA'):getVar('--tileB'));
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
    drawPortals();
    // coins
    ctx.fillStyle=getVar('--coin');
    for(var i=0;i<coins.length;i++){ var c=coins[i]; var cx=c.x*TILE+TILE/2, cy=c.y*TILE+TILE/2; ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fill(); }
    // potions (icone stilizzate)
    for(var k=0;k<potions.length;k++){ var po=potions[k]; var px=po.x*TILE, py=po.y*TILE;
      ctx.fillStyle='#8b5cf6'; ctx.fillRect(px+TILE/2-8,py+TILE/2-14,16,20);
      ctx.fillStyle='#a78bfa'; ctx.fillRect(px+TILE/2-5,py+TILE/2-20,10,6);
      ctx.fillStyle='#6d28d9'; ctx.fillRect(px+TILE/2-6,py+TILE/2-24,12,4);
      ctx.fillStyle='#0006'; ctx.beginPath(); ctx.ellipse(px+TILE/2,py+TILE-12,12,4,0,0,Math.PI*2); ctx.fill();
    }
    // loot bag (icone semplificate)
    var now=performance.now();
    for(var lb=0; lb<lootBags.length; lb++){
      var b=lootBags[lb], bx=b.x*TILE, by=b.y*TILE, remain=b.ttlMs-(now-b.createdAt), warn=remain<=BAG_WARN_MS;
      ctx.save(); if(warn){ var pulse=(Math.sin(now/120)+1)/2; ctx.globalAlpha=0.55+0.4*pulse; }
      ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(bx+TILE/2,by+TILE-10,16,6,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#b45309'; ctx.beginPath(); ctx.moveTo(bx+TILE/2-12,by+TILE/2+6); ctx.lineTo(bx+TILE/2+12,by+TILE/2+6);
      ctx.lineTo(bx+TILE/2+8,by+TILE/2-8); ctx.lineTo(bx+TILE/2-8,by+TILE/2-8); ctx.closePath(); ctx.fill();
      ctx.fillStyle='#78350f'; ctx.fillRect(bx+TILE/2-8,by+TILE/2-8,16,3);
      ctx.fillStyle='#facc15'; ctx.font='bold 14px system-ui'; ctx.textAlign='center'; ctx.fillText('ü™ô', bx+TILE/2, by+TILE/2-12);
      ctx.restore();
    }

    // enemies
    for(var eI=0;eI<enemies.length;eI++){
      var en=enemies[eI], col=(en.type==='ranged')?'#a855f7':getVar('--enemy');
      var ex=(en.vx!=null?en.vx:en.x), ey=(en.vy!=null?en.vy:en.y);
      drawActor(ex,ey,col);
      drawHpBar(ex,ey,en.hp,en.maxHp,true,(target===en));
      if(target===en){ drawTargetRing(ex,ey); }
    }

    // player
    var pxv=(player.vx!=null?player.vx:player.x), pyv=(player.vy!=null?player.vy:player.y);
    drawActor(pxv,pyv,getVar('--player'));
    drawHpBar(pxv,pyv,player.hp,player.maxHp,false,false);

    // projectiles
    for(var pp=0; pp<projectiles.length; pp++){
      var pr=projectiles[pp]; var ptx=(pr.vx!=null?pr.vx:pr.x), pty=(pr.vy!=null?pr.vy:pr.y);
      var px2=ptx*TILE+TILE/2, py2=pty*TILE+TILE/2; ctx.fillStyle='#f87171'; ctx.beginPath(); ctx.arc(px2,py2,6,0,Math.PI*2); ctx.fill();
    }

    drawDmgTexts();
    drawXpBar();
    drawMiniOverlay();

    ctx.fillStyle='#ffffffcc'; ctx.font='bold 14px system-ui'; ctx.fillText('BUILD '+BUILD, 8, cv.height-10);
    statusEl.textContent='LV '+player.lvl+' | HP '+player.hp+'/'+player.maxHp+' | ATK '+player.atkMin+'‚Äì'+player.atkMax+' | coins '+player.coins+' | pots '+player.pots;
  }

  function drawPortals(){
    var list=WORLD.portals[WORLD.current]||[];
    ctx.save();
    for(var i=0;i<list.length;i++){
      var p=list[i];
      ctx.fillStyle='#7c3aed'; ctx.globalAlpha=0.95; ctx.fillRect(p.x*TILE+6, p.y*TILE+6, TILE-12, TILE-12);
      ctx.globalAlpha=0.35; ctx.fillRect(p.x*TILE+3, p.y*TILE+3, TILE-6, TILE-6);
    }
    ctx.restore();
  }
  function drawActor(tx,ty,color){
    var x=tx*TILE, y=ty*TILE;
    ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,18,6,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=color; ctx.fillRect(x+TILE/2-16,y+TILE/2-22,32,36);
  }
  function drawHpBar(tx,ty,hp,maxHp,isEnemy,isTarget){
    var x=tx*TILE, y=ty*TILE, w=40, h=6, px=x+TILE/2-w/2, py=y+TILE/2-32;
    var r=Math.max(0,Math.min(1,hp/maxHp));
    var col='#10b981'; if(isEnemy){ if(r<0.66) col='#f59e0b'; if(r<0.33) col='#ef4444'; }
    ctx.fillStyle=getVar('--hpBack'); ctx.fillRect(px,py,w,h);
    ctx.fillStyle=col; ctx.fillRect(px,py,w*r,h);
    ctx.strokeStyle=isTarget ? '#f87171' : '#0008';
    ctx.lineWidth=isTarget ? 2 : 1; ctx.strokeRect(px,py,w,h); ctx.lineWidth=1;
  }
  function drawTargetRing(tx,ty){
    var x=tx*TILE+TILE/2, y=ty*TILE+TILE/2;
    ctx.save(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,28,0,Math.PI*2); ctx.stroke(); ctx.restore();
  }
  var MAX_LVL=99;
  function xpNeeded(l){ return Math.floor(50*Math.pow(l,1.5)); }
  function drawXpBar(){
    var pad=6,h=10,x=pad,y=pad,w=cv.width-pad*2,need=(player.lvl<MAX_LVL?xpNeeded(player.lvl):1), ratio=(player.lvl<MAX_LVL?Math.max(0,Math.min(1,player.exp/need)):1);
    ctx.fillStyle='rgba(11,18,36,.66)'; ctx.fillRect(x,y,w,h);
    ctx.fillStyle='#7c3aed'; ctx.fillRect(x,y,w*ratio,h);
    ctx.strokeStyle='#1f2a44'; ctx.strokeRect(x,y,w,h);
  }
  function flashCircle(tx,ty,color,alpha,r){ var x=tx*TILE+TILE/2,y=ty*TILE+TILE/2; ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }

  /* --- Log --- */
  var logLines=[];
  function pushLog(html, cls){
    var t=new Date(), hh=String(t.getHours()).padStart(2,'0'), mm=String(t.getMinutes()).padStart(2,'0'), ss=String(t.getSeconds()).padStart(2,'0');
    logLines.push('<div class="line '+(cls||'')+'">['+hh+':'+mm+':'+ss+'] '+html+'</div>');
    if(logLines.length>80) logLines.shift();
    logBody.innerHTML=logLines.join(''); logBody.scrollTop=logBody.scrollHeight;
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,function(m){return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);}); }
  function logDmg(msg){ pushLog(escapeHtml(msg),'dmg'); }
  function logHeal(msg){ pushLog(escapeHtml(msg),'heal'); }
  function logLoot(msg){ pushLog(escapeHtml(msg),'loot'); }
  function logSys(msg){ pushLog(escapeHtml(msg),'sys'); }

  /* --- Death / Respawn --- */
  var dead=false;
  function gameOver(){
    if(dead) return; dead=true;
    autoChase=false; pathQueue=[];
    target=null; hideTargetFrame();
    toast('Sei morto!');
    cv.style.filter='grayscale(1)'; cv.style.opacity='0.6';
    deathOverlay.classList.remove('hidden');
  }
  deathRespawn.onclick=function(){
    // ritorna allo spawn, vita piena
    var res=buildMap('spawn'); map=res.map; applyTheme(res.themeVars); WORLD.current='spawn';
    player.hp=player.maxHp; player.x=1; player.y=Math.floor(ROWS/2); player.vx=player.x; player.vy=player.y;
    coins.length=0; potions.length=0; projectiles.length=0; enemies.length=0; lootBags.length=0;
    dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
    logSys('Respawn effettuato.');
  };
  deathReset.onclick=function(){ location.reload(); };

})();
</script>
</body>
</html>
