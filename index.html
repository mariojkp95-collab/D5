<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Drakoria ‚Äî Stats Build</title>
<style>
:root{
  --bg:#0b1224; --panel:#0f172a; --stroke:#1f2a44; --text:#e5e7eb; --muted:#9ca3af;
  --tileA:#0e2a1e; --tileB:#123022; --block:#15223b;
  --player:#3b82f6; --enemy:#ef4444; --coin:#facc15; --shadow:#0006; --hpBack:#1f2937;
  --accent:#7c3aed; --rare:#60a5fa; --epic:#a78bfa; --legend:#f59e0b;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--stroke)}
header .muted{color:var(--muted);margin-left:8px}
header .btn{background:#26325a;color:#fff;border:1px solid #31406e;border-radius:8px;padding:6px 10px;cursor:pointer}
header .btn:hover{filter:brightness(1.05)}
main{max-width:1400px;margin:14px auto;padding:12px;background:var(--panel);border:1px solid var(--stroke);border-radius:12px;position:relative}
#game{display:block;width:100%;height:auto;border-radius:10px;border:1px solid var(--stroke);background:#0a1630;image-rendering:pixelated;touch-action:none}
.help{margin:.6rem 0 0;color:#a1a1aa}
#status{margin-top:8px;color:var(--muted)}
.err{position:fixed;left:50%;top:70px;transform:translateX(-50%);background:#7f1d1d;color:#fff;border:1px solid #fecaca;border-radius:8px;padding:8px 12px;z-index:50;font-weight:600;max-width:90vw;white-space:pre-wrap;display:none}

/* Log */
.log{position:fixed; left:16px; bottom:16px; width:300px; max-width:80vw;
  background:rgba(15,23,42,.9); border:1px solid #1f2a44; border-radius:10px; padding:8px 10px; z-index:26}
.log .h{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-weight:700}
.log .b{max-height:160px; overflow:auto; font:12px/1.3 system-ui}
.log .line{margin:2px 0}
.log .dmg{color:#fca5a5}
.log .heal{color:#86efac}
.log .loot{color:#fde68a}
.log .sys{color:#93c5fd}

/* Game Over */
.death{position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:60}
.death.hidden{display:none}
.death-box{background:#0f172a; border:1px solid #1f2a44; padding:14px; border-radius:12px; width:min(420px,92vw); box-shadow:0 18px 44px rgba(0,0,0,.55)}
.death-title{font-weight:800; font-size:18px; margin-bottom:8px}
.death-sub{color:#cbd5e1; margin-bottom:12px}
.death-actions{display:flex; gap:8px; justify-content:flex-end}
.btn{border:1px solid #31406e;background:#2563eb;color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
.btn:disabled{background:#1f2a44;color:#9aa0ad;cursor:not-allowed}

/* Character (stats) */
.char{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:520px; max-width:95vw;
     background:#0f172a; border:1px solid #1f2a44; border-radius:12px; box-shadow:0 18px 44px rgba(0,0,0,.45); z-index:46}
.char-h{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #1f2a44;font-weight:700}
.char-x{width:32px;height:26px;border-radius:6px;border:1px solid #31406e;background:#26325a;color:#fff;cursor:pointer}
.char-b{padding:12px}
.stat-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
.stat{display:flex; justify-content:space-between; align-items:center; background:#0b1224; border:1px solid #2a355c; border-radius:10px; padding:8px}
.stat .k{color:#93c5fd; font-weight:700}
.stat .v{font-weight:700}
.hidden{display:none}

/* Toast */
.toast{position:fixed; left:50%; bottom:84px; transform:translateX(-50%); background:rgba(15,23,42,.9); border:1px solid #1f2a44; color:#e5e7eb; padding:6px 10px; border-radius:10px; z-index:55; display:none}
</style>
</head>
<body>
<header>
  <div><strong>Drakoria</strong> <span class="muted">stats build</span></div>
  <div>
    <button id="btnChar" class="btn">Personaggio</button>
    <button id="btnSave" class="btn">Save</button>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnReset" class="btn">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="1344" height="768" aria-label="Gioco"></canvas>
  <p class="help">
    Tap per muoverti ‚Ä¢ tap su un nemico per target ‚Ä¢ doppio tap/press prolungato per auto-inseguire ‚Ä¢ SPAZIO/üó°Ô∏è attacca.  
    Portale viola tra Spawn ‚Üî Main (arcieri). Pannello <b>Personaggio</b> per le nuove statistiche.
  </p>
  <div id="status"></div>
</main>

<section class="log" id="logPanel"><div class="h"><span>Log</span></div><div id="logBody" class="b"></div></section>
<div id="errBox" class="err"></div>
<div id="toast" class="toast"></div>

<!-- Game Over -->
<div id="deathOverlay" class="death hidden" role="dialog" aria-modal="true" aria-label="Game Over">
  <div class="death-box">
    <div class="death-title">Sei morto</div>
    <div class="death-sub">Respawn ti riporta allo spawn con vita piena.</div>
    <div class="death-actions">
      <button id="deathRespawn" class="btn">Respawn</button>
      <button id="deathReset" class="btn">Reset</button>
    </div>
  </div>
</div>

<!-- Character (stats) -->
<section id="charWin" class="char hidden" role="dialog" aria-modal="true" aria-label="Personaggio">
  <div class="char-h"><span>Personaggio</span><button id="charClose" class="char-x">√ó</button></div>
  <div class="char-b">
    <div id="charBasics" class="stat-grid" style="margin-bottom:10px"></div>
    <div id="charStats" class="stat-grid"></div>
  </div>
</section>

<script>
(function(){
  const BUILD='STATS-1';
  const SAVE_KEY='save_stats_build';
  const cv=document.getElementById('game'); const ctx=cv.getContext('2d');

  /* UI */
  const statusEl=document.getElementById('status');
  const errBox=document.getElementById('errBox');
  const logBody=document.getElementById('logBody');
  const toastEl=document.getElementById('toast');
  const deathOverlay=document.getElementById('deathOverlay');
  const deathRespawn=document.getElementById('deathRespawn');
  const deathReset=document.getElementById('deathReset');
  const btnChar=document.getElementById('btnChar');
  const charWin=document.getElementById('charWin');
  const charClose=document.getElementById('charClose');
  const charBasics=document.getElementById('charBasics');
  const charStats=document.getElementById('charStats');
  const btnSave=document.getElementById('btnSave');
  const btnLoad=document.getElementById('btnLoad');
  const btnReset=document.getElementById('btnReset');

  function panic(where,e){
    errBox.style.display='block';
    errBox.textContent='ERRORE '+where+': '+(e && (e.message||e));
    console.error('[PANIC]', where, e);
  }
  function toast(msg){
    toastEl.textContent=msg;
    toastEl.style.display='block';
    clearTimeout(toastEl.__t);
    toastEl.__t=setTimeout(()=>toastEl.style.display='none',1100);
  }
  function logLine(msg,cls){ const t=new Date(); const hh=String(t.getHours()).padStart(2,'0'), mm=String(t.getMinutes()).padStart(2,'0'), ss=String(t.getSeconds()).padStart(2,'0'); logBody.innerHTML+=`<div class="line ${cls||''}">[${hh}:${mm}:${ss}] ${escapeHtml(msg)}</div>`; logBody.scrollTop=logBody.scrollHeight; }
  function logDmg(m){ logLine(m,'dmg'); }
  function logHeal(m){ logLine(m,'heal'); }
  function logSys(m){ logLine(m,'sys'); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  /* World */
  const COLS=21, ROWS=12, TILE=64; cv.width=COLS*TILE; cv.height=ROWS*TILE;
  const WORLD={ current:'spawn', portals:makePortals() };
  const THEMES={ main:{'--tileA':'#0e2a1e','--tileB':'#123022'}, spawn:{'--tileA':'#1e1f3a','--tileB':'#23264a'} };
  let map=[];
  function makePortals(){ const mid=ROWS>>1; return { main:[{x:1,y:mid,to:'spawn',tx:COLS-2,ty:mid}], spawn:[{x:COLS-2,y:mid,to:'main',tx:1,ty:mid}] }; }
  function isPortalTile(world,x,y){ const list=WORLD.portals[world]||[]; for(let i=0;i<list.length;i++){ const p=list[i]; if(p.x===x&&p.y===y) return true; } return false; }
  function applyTheme(vars){ const root=document.documentElement.style; for(const k in vars) root.setProperty(k, vars[k]); }
  function buildMap(name){
    const m=[]; for(let y=0;y<ROWS;y++){ const row=[]; for(let x=0;x<COLS;x++) row.push(0); m.push(row); }
    if(name==='main'){ for(let i=0;i<16;i++){ const bx=(Math.random()*COLS|0), by=(Math.random()*ROWS|0); if(isPortalTile('main',bx,by)) continue; m[by][bx]=1; } }
    return {map:m, theme:(name==='main')?THEMES.main:THEMES.spawn};
  }

  /* Utils */
  function inside(x,y){ return x>=0&&y>=0&&x<COLS&&y<ROWS; }
  function rndInt(a,b){ return a+((Math.random()*(b-a+1))|0); }
  function walkable(x,y){ if(!inside(x,y)) return false; if(map[y][x]===1) return false; return true; }
  function tileFree(x,y){ if(map[y][x]!==0) return false; if(x===player.x&&y===player.y) return false; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===x&&e.y===y) return false; } return true; }
  function chebyshev(a,b){ const dx=Math.abs(a.x-b.x), dy=Math.abs(a.y-b.y); return dx>dy?dx:dy; }
  function randEmpty(){ for(let t=0;t<200;t++){ const x=rndInt(0,COLS-1), y=rndInt(0,ROWS-1); if(walkable(x,y)&&tileFree(x,y)) return {x,y}; } return {x:1,y:1}; }
  function getVar(n){ const cs=getComputedStyle(document.documentElement); return cs.getPropertyValue(n).trim(); }

  /* BFS pathfinding */
  function bfs(sx,sy,tx,ty){
    if(!walkable(tx,ty)) return null;
    const q=[{x:sx,y:sy}], prev={}, seen={}; let head=0; seen[sx+','+sy]=1;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(head<q.length){
      const c=q[head++]; if(c.x===tx&&c.y===ty){
        const path=[]; let k=tx+','+ty;
        while(prev[k]){ const s=k.split(','); path.push({x:+s[0],y:+s[1]}); k=prev[k].x+','+prev[k].y; }
        path.reverse(); return path;
      }
      for(let d=0; d<4; d++){
        const nx=c.x+dirs[d][0], ny=c.y+dirs[d][1], kk=nx+','+ny;
        if(!walkable(nx,ny)||seen[kk]) continue; seen[kk]=1; prev[kk]={x:c.x,y:c.y}; q.push({x:nx,y:ny});
      }
    }
    return null;
  }
  function bfsToAdjacencySmart(sx,sy,tx,ty,etype){
    const opts=[[tx+1,ty],[tx-1,ty],[tx,ty+1],[tx,ty-1]]; let best=null, bestScore=1e9;
    for(let i=0;i<opts.length;i++){
      const ax=opts[i][0], ay=opts[i][1]; if(!walkable(ax,ay)) continue;
      let occ=false; for(let j=0;j<enemies.length;j++){ const e=enemies[j]; if(e.x===ax&&e.y===ay){ occ=true; break; } }
      if(occ) continue;
      const p=bfs(sx,sy,ax,ay); if(!p) continue; let score=p.length; if(etype==='ranged'&&(ax===tx||ay===ty)) score+=2;
      if(score<bestScore){ bestScore=score; best=p; }
    }
    return best;
  }

  /* Tween */
  let MOVE_MS=110;
  function startTween(o,fx,fy,tx,ty,now){ o.vFromX=fx; o.vFromY=fy; o.vToX=tx; o.vToY=ty; o.vStart=now; o.vEnd=now+MOVE_MS; if(o.vx==null)o.vx=fx; if(o.vy==null)o.vy=fy; }
  function tweenUpdate(o,now){
    if(!o) return; const has=(o.vStart&&o.vEnd&&o.vEnd>o.vStart);
    if(has && now<o.vEnd){ let t=(now-o.vStart)/(o.vEnd-o.vStart); t=t*t*(3-2*t); o.vx=o.vFromX+(o.vToX-o.vFromX)*t; o.vy=o.vFromY+(o.vToY-o.vFromY)*t; }
    else { if(o.x!=null) o.vx=o.x; if(o.y!=null) o.vy=o.y; o.vStart=0; o.vEnd=0; }
  }
  function updateTweens(){ const now=performance.now(); tweenUpdate(player,now); for(let i=0;i<enemies.length;i++) tweenUpdate(enemies[i],now); for(let j=0;j<projectiles.length;j++) tweenUpdate(projectiles[j],now); }

  /* Player + Stats */
  const player={
    x:12,y:4,
    baseMaxHp:100, baseAtkMin:6, baseAtkMax:12,
    maxHp:100, hp:100, atkMin:6, atkMax:12,
    baseCrit:0.10, // 10% base
    coins:0,pots:1,lastAtk:0,atkCd:450,lvl:1,exp:0,
    // --- nuove stats ---
    stats:{
      atkSpeed: 0.00,   // +% velocit√† attacco
      critDmg: 0.50,    // +50% (di default)
      luck:    0.00,    // +% crit chance
      defense: 0,       // flat
      mitigation: 0.00, // % (cap 0.60)
      projRes: 0.00,    // % vs proiettili
      bleedRes:0.00     // % vs bleed (cap 0.70)
    },
    status:{ bleed:null }
  };
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function getCritChance(){ return clamp(player.baseCrit + (player.stats.luck||0), 0, 0.90); }
  function getAtkCd(){ // effettivo con atkSpeed
    const eff = player.atkCd * (1 - (player.stats.atkSpeed||0));
    return Math.max(180, Math.floor(eff));
  }
  function recomputeStats(heal){
    player.maxHp = player.baseMaxHp;
    player.atkMin = player.baseAtkMin;
    player.atkMax = player.baseAtkMax;
    if(heal) player.hp = player.maxHp;
    if(player.hp>player.maxHp) player.hp=player.maxHp;
    renderCharIfOpen();
  }

  /* Enemies */
  let enemies=[], projectiles=[];
  let _eid=1; function giveId(e){ e.id=_eid++; return e; }
  function makeArcher(x,y){
    const e={ kind:'archer', type:'ranged', x,y, spawnX:x, spawnY:y,
      hp:44, maxHp:44, atkCd:1200, lastShot:0, rangeMin:3, rangeMax:7,
      pokeCd:700, lastPoke:0,
      aggro:false, aggroRange:7, leashRange:15, loseAggroMs:6000, lastSeenTs:0,
      moveTick:0, moveEvery:6, path:[], mode:'idle', windupMs:400, windupStart:null
    };
    e.vx=x; e.vy=y; return giveId(e);
  }
  function spawnMain(){
    enemies.length=0;
    // 2 gruppi pattuglia leggeri
    createPatrolGroup(4, 5, COLS-4, 3, 2);
    createPatrolGroup(4, 5, COLS-5, ROWS-4, 2);
  }
  let _grpId=1;
  function createPatrolGroup(count, anchorX, anchorY, radius){
    const id='g'+(_grpId++); for(let i=0;i<count;i++){
      const pos=findFreeNear(anchorX,anchorY,radius||2,30);
      const e=makeArcher(pos.x,pos.y); e.groupId=id; e.groupAnchor={x:anchorX,y:anchorY}; e.patrolRadius=radius||2;
      enemies.push(e);
    }
  }
  function findFreeNear(cx,cy,r,tries){ tries=tries||30;
    for(let k=0;k<tries;k++){ const nx=clamp(Math.round(cx+rndInt(-r,r)),0,COLS-1), ny=clamp(Math.round(cy+rndInt(-r,r)),0,ROWS-1);
      if(walkable(nx,ny)&&tileFree(nx,ny)&&!isPortalTile(WORLD.current,nx,ny)) return {x:nx,y:ny};
    } return randEmpty();
  }

  /* Init world: spawn vuota */
  (function initSpawn(){
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn'; enemies.length=0; recomputeStats(true);
  })();

  /* Input & HUD in-canvas */
  const HUD={ atk:null, pot:null, loot:null, char:null };
  function layoutHud(){
    HUD.atk  = { x: cv.width - 86,  y: cv.height - 86, w: 72, h: 72 };
    HUD.pot  = { x: cv.width - 166, y: cv.height - 86, w: 72, h: 72 };
    HUD.loot = { x: 14,             y: cv.height - 86, w: 72, h: 72 };
    HUD.char = { x: cv.width - 86,  y: 14,             w: 72, h: 54 };
  }
  window.addEventListener('resize', layoutHud, false);
  layoutHud();

  let target=null, autoChase=false, lastEnemyTapTs=0, lastEnemyTapId=-1;
  let pathQueue=[], holdTimer=null, destMarker=null;
  let dead=false;

  btnChar.onclick=()=>{ charWin.classList.toggle('hidden'); renderCharPanel(); };
  charClose.onclick=()=>{ charWin.classList.add('hidden'); };

  function canvasToTile(ev){
    const r=cv.getBoundingClientRect(), t=ev.touches&&ev.touches[0];
    const cx=t?t.clientX:ev.clientX, cy=t?t.clientY:ev.clientY;
    const sx=(cx-r.left)*(cv.width/r.width), sy=(cy-r.top)*(cv.height/r.height);
    const tx = Math.max(0, Math.min(COLS-1, (sx/TILE)|0));
    const ty = Math.max(0, Math.min(ROWS-1, (sy/TILE)|0));
    return {sx, sy, tx, ty};
  }
  function enemyRect(e){ const x=e.x*TILE+TILE/2-16, y=e.y*TILE+TILE/2-22; return {x,y,w:32,h:36}; }
  function inRect(px,py,r){ return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h; }
  function getEnemyAtScreen(sx,sy){ for(let i=0;i<enemies.length;i++){ const ee=enemies[i]; if(inRect(sx,sy,enemyRect(ee))) return ee; } return null; }

  function onPointerDown(ev){
    if(dead) return;
    const m=canvasToTile(ev), pos={sx:m.sx,sy:m.sy};
    clearTimeout(holdTimer);
    holdTimer=setTimeout(()=>{ const enemy=getEnemyAtScreen(pos.sx,pos.sy); if(enemy){ target=enemy; autoChase=true; pathQueue=[]; updateTargetFrame(); toast('Auto-inseguimento'); draw(); } },500);
  }
  function onPointerUp(ev){
    if(dead) return;
    clearTimeout(holdTimer);
    const m=canvasToTile(ev), now=performance.now();

    // HUD
    if(inRect(m.sx,m.sy,HUD.atk)){ tryAttackAdjacent(); return; }
    if(inRect(m.sx,m.sy,HUD.pot)){ usePotion(); return; }
    if(inRect(m.sx,m.sy,HUD.loot)){ /* no loot window in this minimal build */ return; }
    if(inRect(m.sx,m.sy,HUD.char)){ charWin.classList.toggle('hidden'); renderCharPanel(); return; }

    // Target / movimento
    const clicked=getEnemyAtScreen(m.sx,m.sy);
    if(clicked){
      if(lastEnemyTapId===clicked.id && (now-lastEnemyTapTs)<=350){ target=clicked; autoChase=true; pathQueue=[]; }
      else { target=clicked; autoChase=false; }
      lastEnemyTapId=clicked.id; lastEnemyTapTs=now; updateTargetFrame(); draw(); return;
    }

    autoChase=false;
    const p=bfs(player.x,player.y,m.tx,m.ty);
    if(p && p.length){ pathQueue=p; destMarker={x:m.tx,y:m.ty,ttl:1400}; }
    else{
      const dx=Math.sign(m.tx-player.x), dy=Math.sign(m.ty-player.y);
      const tryFirst=(Math.abs(m.tx-player.x)>=Math.abs(m.ty-player.y))?[{x:player.x+dx,y:player.y},{x:player.x,y:player.y+dy}]:[{x:player.x,y:player.y+dy},{x:player.x+dx,y:player.y}];
      for(let k=0;k<tryFirst.length;k++){ const nxt=tryFirst[k]; if(inside(nxt.x,nxt.y)&&walkable(nxt.x,nxt.y)){ pathQueue=[nxt]; destMarker={x:nxt.x,y:nxt.y,ttl:700}; break; } }
    }
    if(target && chebyshev(player,target)===1 && (now-player.lastAtk)>=getAtkCd()) { attackEnemy(target); return; }
    draw(); updateTargetFrame();
  }
  cv.addEventListener('pointerdown', onPointerDown, {passive:false});
  cv.addEventListener('pointerup', onPointerUp, {passive:false});
  cv.addEventListener('click', onPointerUp, false);
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.key===' ') tryAttackAdjacent(); }, false);

  function tryAttackAdjacent(){
    const now=performance.now(); if(now-player.lastAtk<getAtkCd()) return false;
    if(target && chebyshev(player,target)===1){ attackEnemy(target); return true; }
    for(let i=0;i<enemies.length;i++){ const en=enemies[i]; if(chebyshev(player,en)===1){ attackEnemy(en); return true; } }
    return false;
  }

  /* Combat + bleed */
  const dmgTexts=[];
  function addDmgText(tx,ty,txt,color){ const px=tx*TILE+TILE/2, py=ty*TILE+TILE/2-28; dmgTexts.push({x:px,y:py,txt,color,ttl:700,vy:-0.04}); }
  function updateDmgTexts(dt){ for(let i=dmgTexts.length-1;i>=0;i--){ const d=dmgTexts[i]; d.ttl-=dt; d.y+=d.vy*dt; if(d.ttl<=0) dmgTexts.splice(i,1); } }
  function drawDmgTexts(){ for(let i=0;i<dmgTexts.length;i++){ const d=dmgTexts[i]; const a=Math.max(0,Math.min(1,d.ttl/700)); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=d.color; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(d.txt,d.x,d.y); ctx.restore(); } }

  function rollCrit(ch){ return Math.random() < ch; }
  function attackEnemy(t){
    const now=performance.now(); player.lastAtk=now;
    const base=rndInt(player.atkMin,player.atkMax);
    const crit = rollCrit(getCritChance());
    const mult = crit ? (1 + (player.stats.critDmg||0)) : 1;
    const dmg = Math.max(0, Math.floor(base * mult));
    t.hp = Math.max(0, t.hp - dmg);
    addDmgText(t.x,t.y,(crit?'CRIT ':'-')+dmg, crit ? '#facc15' : '#ffd166');
    if(t.hp===0){
      if(target===t){ target=null; autoChase=false; hideTargetFrame(); }
      logSys('Nemico sconfitto.');
      enemies.splice(enemies.indexOf(t),1);
      // respawn semplice: rimpiazza dopo 1s altrove
      setTimeout(()=>{ if(WORLD.current==='main'){ const s=randEmpty(); enemies.push(makeArcher(s.x,s.y)); } }, 1000);
    }
    draw(); updateTargetFrame();
  }

  function applyDamageReduction(amount, source){
    // Difesa flat
    let dmg = Math.max(0, amount - (player.stats.defense|0));
    // Mitigazione %
    const miti = clamp(player.stats.mitigation||0, 0, 0.60);
    dmg = Math.floor(dmg * (1 - miti));
    // Proiettili %
    if(source==='projectile'){
      const pr = clamp(player.stats.projRes||0, 0, 0.95);
      dmg = Math.floor(dmg * (1 - pr));
    }
    return Math.max(0, dmg|0);
  }

  function takePlayerDamage(amount, label, source){
    const dmg = applyDamageReduction(amount, source);
    player.hp = Math.max(0, player.hp - dmg);
    addDmgText(player.x, player.y, label + dmg, '#ff6b6b');
    if(player.hp===0) gameOver();
  }

  function applyBleed(ticks, tickDmgBase, periodMs){
    const res = clamp(player.stats.bleedRes||0, 0, 0.70);
    const tickDmg = Math.max(1, Math.floor(tickDmgBase * (1 - res)));
    player.status.bleed = { ticksLeft:ticks, nextTs:performance.now()+periodMs, period:periodMs, tick:tickDmg };
    logDmg('Sanguinamento applicato ('+ticks+'√ó '+tickDmg+').');
  }
  function updateBleed(now){
    const b=player.status.bleed; if(!b) return;
    if(now>=b.nextTs && b.ticksLeft>0){
      b.ticksLeft--; b.nextTs=now+b.period;
      takePlayerDamage(b.tick, '-','bleed');
      if(b.ticksLeft<=0) player.status.bleed=null;
    }
  }

  function gameOver(){
    dead=true; autoChase=false; pathQueue=[]; target=null; hideTargetFrame();
    cv.style.filter='grayscale(1)'; cv.style.opacity='0.6';
    deathOverlay.classList.remove('hidden');
  }
  deathRespawn.onclick=()=>{
    // teleporta allo spawn, cura full
    const hit = (WORLD.portals[WORLD.current]||[]).find(p=>p.to==='spawn') || {tx:COLS-2, ty:(ROWS>>1)};
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn';
    player.x = Math.max(1,Math.min(COLS-2, hit.tx)); player.y=Math.max(1,Math.min(ROWS-2, hit.ty));
    player.hp=player.maxHp; player.status.bleed=null;
    enemies.length=0; projectiles.length=0; pathQueue=[];
    dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
    draw();
  };
  deathReset.onclick=()=>location.reload();

  /* Enemy AI + projectiles */
  function hasLoS(ax,ay,bx,by){
    if(ax===bx){ const step=(ay<by)?1:-1; for(let y=ay+step; y!==by; y+=step){ if(map[y][ax]===1) return false; } return true; }
    if(ay===by){ const st=(ax<bx)?1:-1; for(let x=ax+st; x!==bx; x+=st){ if(map[ay][x]===1) return false; } return true; }
    return false;
  }

  /* Draw */
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    // tiles
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?getVar('--block'):(((x+y)%2===0)?getVar('--tileA'):getVar('--tileB'));
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
    // portals
    drawPortals();

    // enemies
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; const ex=(e.vx!=null?e.vx:e.x), ey=(e.vy!=null?e.vy:e.y);
      drawActor(ex,ey,getVar('--enemy'));
      drawHpBar(ex,ey,e.hp,e.maxHp,true,(target===e));
      if(target===e) drawTargetRing(ex,ey);
    }

    // player
    const pxv=(player.vx!=null?player.vx:player.x), pyv=(player.vy!=null?player.vy:player.y);
    drawActor(pxv,pyv,getVar('--player')); drawHpBar(pxv,pyv,player.hp,player.maxHp,false,false);

    // projectiles
    for(let p=0;p<projectiles.length;p++){
      const pr=projectiles[p]; const ptx=(pr.vx!=null?pr.vx:pr.x), pty=(pr.vy!=null?pr.vy:pr.y);
      const x=ptx*TILE+TILE/2, y=pty*TILE+TILE/2; ctx.fillStyle='#f87171'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
    }

    // dmg texts
    drawDmgTexts();

    // HUD overlay
    drawHud();

    // status
    statusEl.textContent=`build: ${BUILD} | HP ${player.hp}/${player.maxHp} | ATK ${player.atkMin}‚Äì${player.atkMax} | Crit ${(getCritChance()*100)|0}% | atkCD ${getAtkCd()}ms`;
  }

  function drawPortals(){
    const list=WORLD.portals[WORLD.current]||[];
    ctx.save();
    for(let i=0;i<list.length;i++){
      const p=list[i];
      ctx.fillStyle='#7c3aed'; ctx.globalAlpha=0.95; ctx.fillRect(p.x*TILE+6,p.y*TILE+6,TILE-12,TILE-12);
      ctx.globalAlpha=0.35; ctx.fillRect(p.x*TILE+3,p.y*TILE+3,TILE-6,TILE-6);
    }
    ctx.restore();
  }
  function drawActor(tx,ty,color){
    const x=tx*TILE, y=ty*TILE;
    ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,18,6,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=color; ctx.fillRect(x+TILE/2-16,y+TILE/2-22,32,36);
  }
  function drawHpBar(tx,ty,hp,maxHp,isEnemy,isTarget){
    const x=tx*TILE, y=ty*TILE, w=40, h=6, px=x+TILE/2-w/2, py=y+TILE/2-32;
    const r=Math.max(0,Math.min(1,hp/maxHp));
    let col='#10b981'; if(isEnemy){ if(r<0.66) col='#f59e0b'; if(r<0.33) col='#ef4444'; }
    ctx.fillStyle=getVar('--hpBack'); ctx.fillRect(px,py,w,h);
    ctx.fillStyle=col; ctx.fillRect(px,py,w*r,h);
    ctx.strokeStyle=isTarget?'#f87171':'#0008'; ctx.lineWidth=isTarget?2:1; ctx.strokeRect(px,py,w,h); ctx.lineWidth=1;
  }
  function drawTargetRing(tx,ty){ const x=tx*TILE+TILE/2, y=ty*TILE+TILE/2; ctx.save(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,28,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function roundRectPath(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawHudBtn(r, glyph, enabled){ ctx.save(); ctx.globalAlpha=enabled?1:0.55; ctx.fillStyle='rgba(15,23,42,.85)'; ctx.strokeStyle='#1f2a44'; ctx.lineWidth=2; roundRectPath(r.x,r.y,r.w,r.h,12); ctx.fill(); ctx.stroke(); ctx.font='28px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#e5e7eb'; ctx.fillText(glyph, r.x + r.w/2, r.y + r.h/2); ctx.restore(); }
  function drawHud(){
    drawHudBtn(HUD.atk, 'üó°Ô∏è', (performance.now()-player.lastAtk)>=getAtkCd());
    drawHudBtn(HUD.pot, 'üçµ', player.pots>0);
    drawHudBtn(HUD.loot, 'üëú', false);
    // tasto personaggio
    drawHudBtn(HUD.char, 'üë§', true);
    // marker destinazione
    if(destMarker && destMarker.ttl>0){
      const a = Math.min(1, destMarker.ttl/400);
      ctx.save(); ctx.globalAlpha = a; ctx.strokeStyle='#93c5fd'; ctx.lineWidth=2;
      const cx=destMarker.x*TILE+TILE/2, cy=destMarker.y*TILE+TILE/2;
      ctx.beginPath(); ctx.arc(cx,cy,20,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }

  /* Target frame (lite) */
  function updateTargetFrame(){ /* visual gi√† sul canvas */ }
  function hideTargetFrame(){ /* no-op */ }

  /* Loop */
  let lastStepTs=performance.now();
  function step(){
    try{
      const now=performance.now();
      const dt = Math.min(200, now-lastStepTs)|0; lastStepTs=now;

      // Path follow (player): consuma tutta la coda
      if(!dead && pathQueue.length){
        const next = pathQueue[0];
        let blocked=!walkable(next.x,next.y);
        for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===next.x&&e.y===next.y){ blocked=true; break; } }
        if(blocked){ pathQueue.length=0; }
        else{
          const fx=player.x, fy=player.y; player.x=next.x; player.y=next.y; startTween(player,fx,fy,player.x,player.y,now);
          pathQueue.shift();
        }
      }

      // Portali
      if(checkPortalEnter()){
        // switch mappa
        if(WORLD.current==='main'){
          const res=buildMap('main'); map=res.map; applyTheme(res.theme);
          spawnMain();
        } else {
          const res=buildMap('spawn'); map=res.map; applyTheme(res.theme);
          enemies.length=0; projectiles.length=0;
        }
        draw();
      }

      // Enemy AI
      for(let j=0;j<enemies.length;j++){
        const e=enemies[j];
        // aggro
        const distC=chebyshev(e,player);
        if(!e.aggro && distC<=e.aggroRange){ e.aggro=true; e.lastSeenTs=now; }
        const tooFar = chebyshev({x:e.spawnX,y:e.spawnY}, player) > e.leashRange || distC > e.leashRange;
        if(e.aggro){
          if(hasLoS(e.x,e.y,player.x,player.y) || distC<=1) e.lastSeenTs=now;
          if(tooFar || (now - e.lastSeenTs) > e.loseAggroMs){
            e.aggro=false; e.path = bfs(e.x,e.y,e.spawnX,e.spawnY)||[]; e.mode='return';
          }
        }
        e.moveTick=(e.moveTick+1)%e.moveEvery;
        const canMove=(e.moveTick===0);

        if(e.aggro){
          const distM=Math.abs(e.x-player.x)+Math.abs(e.y-player.y);
          const inRange = (distM>=e.rangeMin && distM<=e.rangeMax && hasLoS(e.x,e.y,player.x,player.y));
          if(inRange){
            if(now-e.lastShot>=e.atkCd){
              e.lastShot=now;
              // windup breve, poi scocca
              e.windupStart=now;
              setTimeout(()=>{
                const dx=(player.x===e.x)?0:(player.x>e.x?1:-1);
                const dy=(player.y===e.y)?0:(player.y>e.y?1:-1);
                if(dx||dy) projectiles.push({x:e.x,y:e.y,dx,dy,spdTick:0,dmg:rndInt(6,10), vx:e.x, vy:e.y, vStart:0,vEnd:0, bleedChance:0.3});
              }, e.windupMs);
            }
            // se troppo vicino, prova passo indietro
            if(distM<e.rangeMin && canMove){
              const backX=e.x + (player.x<e.x?1:(player.x>e.x?-1:0));
              const backY=e.y + (player.y<e.y?1:(player.y>e.y?-1:0));
              if(walkable(backX,backY) && !(backX===player.x&&backY===player.y)){
                const fx=e.x, fy=e.y; e.x=backX; e.y=backY; startTween(e,fx,fy,e.x,e.y,now);
              }
            }
          } else {
            if(canMove){
              if(chebyshev(e,player)>1 || !hasLoS(e.x,e.y,player.x,player.y)){
                e.path = bfsToAdjacencySmart(e.x,e.y,player.x,player.y,'ranged') || e.path || [];
              }
              tryStepAlongPath(e, now);
            }
          }
        } else {
          // rientro
          if((e.x!==e.spawnX || e.y!==e.spawnY)){
            if(canMove){
              if(!e.path || !e.path.length) e.path=bfs(e.x,e.y,e.spawnX,e.spawnY)||[];
              tryStepAlongPath(e, now);
            }
          }
        }
      }

      // Proiettili
      for(let pi=projectiles.length-1; pi>=0; pi--){
        const pr=projectiles[pi];
        pr.spdTick=(pr.spdTick+1)%2; if(pr.spdTick!==0) continue;
        const nx=pr.x+pr.dx, ny=pr.y+pr.dy;
        if(!inside(nx,ny) || map[ny][nx]===1){ projectiles.splice(pi,1); continue; }
        if(nx===player.x && ny===player.y){
          // colpito
          const base=rndInt(pr.dmg-1, pr.dmg+1);
          takePlayerDamage(base, '-', 'projectile');
          // bleed chance
          if(Math.random() < (pr.bleedChance||0)){
            applyBleed(4, 4, 700); // 4 tick da 4 base, ogni 0.7s (ridotti da bleedRes)
          }
          projectiles.splice(pi,1);
          continue;
        }
        startTween(pr, pr.x, pr.y, nx, ny, now);
        pr.x=nx; pr.y=ny;
      }

      // Auto-chase & auto-attack
      if(autoChase && target && !dead){
        const stillThere = enemies.indexOf(target)!==-1;
        if(!stillThere){ autoChase=false; target=null; hideTargetFrame(); }
        if(target){
          if(chebyshev(player,target)!==1 && pathQueue.length===0){
            const pAdj=bfsToAdjacencySmart(player.x,player.y,target.x,target.y,target.type);
            if(pAdj && pAdj.length) pathQueue=pAdj;
          }
          if(chebyshev(player,target)===1){
            const nowA=performance.now(); if(nowA-player.lastAtk>=getAtkCd()) attackEnemy(target);
          }
        }
      }

      // Bleed tick
      updateBleed(now);

      // dmg texts
      updateDmgTexts(dt);
      if(destMarker){ destMarker.ttl -= dt; if(destMarker.ttl<=0) destMarker=null; }

      // Render
      updateTweens();
      draw();

    }catch(e){ panic('step', e); }
  }
  function tryStepAlongPath(e, now){
    if(!e.path || !e.path.length) return;
    const nxt=e.path.shift();
    if(!walkable(nxt.x,nxt.y)) { e.path=[]; return; }
    for(let k=0;k<enemies.length;k++){ const other=enemies[k]; if(other!==e && other.x===nxt.x && other.y===nxt.y){ e.path=[]; return; } }
    if(nxt.x===player.x && nxt.y===player.y){ e.path=[]; return; }
    const fx=e.x, fy=e.y; e.x=nxt.x; e.y=nxt.y; startTween(e,fx,fy,e.x,e.y,now);
  }

  function checkPortalEnter(){
    const list=WORLD.portals[WORLD.current]||[];
    for(let i=0;i<list.length;i++){
      const p=list[i];
      if(p.x===player.x && p.y===player.y){
        // teleport
        const res=buildMap(p.to); map=res.map; applyTheme(res.theme); WORLD.current=p.to;
        // posizione uscita sicura
        const nx=clamp(p.tx,1,COLS-2), ny=clamp(p.ty,1,ROWS-2);
        player.x=nx; player.y=ny; player.vx=nx; player.vy=ny; pathQueue.length=0;
        logSys('Teletrasporto: '+(WORLD.current==='main'?'Main':'Spawn'));
        return true;
      }
    }
    return false;
  }

  /* Character panel rendering */
  function pct(v){ return Math.round((v||0)*100); }
  function renderCharPanel(){
    if(charWin.classList.contains('hidden')) return;
    const basics=[
      ['Livello','LV '+player.lvl],
      ['HP',''+player.hp+' / '+player.maxHp],
      ['Attacco',''+player.atkMin+'‚Äì'+player.atkMax],
      ['Crit Chance', pct(getCritChance())+'%'],
      ['Crit Damage', pct(player.stats.critDmg||0)+'%'],
      ['CD Attacco', getAtkCd()+' ms']
    ];
    const stats=[
      ['Difesa (flat)', (player.stats.defense|0)],
      ['Mitigazione', pct(clamp(player.stats.mitigation||0,0,0.60))+'%'],
      ['Res. Proiettili', pct(player.stats.projRes||0)+'%'],
      ['Res. Bleed', pct(clamp(player.stats.bleedRes||0,0,0.70))+'%'],
      ['Vel. Attacco', pct(player.stats.atkSpeed||0)+'%'],
      ['Luck (Crit +)', pct(player.stats.luck||0)+'%']
    ];
    charBasics.innerHTML = basics.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
    charStats.innerHTML  = stats.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
  }
  function renderCharIfOpen(){ renderCharPanel(); }

  /* Save/Load/Reset */
  btnSave.onclick=()=>{
    try{
      localStorage.setItem(SAVE_KEY, JSON.stringify({map, player, enemies, world:WORLD.current}));
      toast('Salvato');
    }catch(e){ panic('save', e); }
  };
  btnLoad.onclick=()=>{
    try{
      const raw=localStorage.getItem(SAVE_KEY); if(!raw) return alert('Nessun salvataggio.');
      const d=JSON.parse(raw);
      if(d && d.map && d.map.length===ROWS){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) map[y][x]=d.map[y][x]|0; }
      if(d && d.player){ for(const k in d.player){ if(d.player.hasOwnProperty(k)) player[k]=d.player[k]; } }
      enemies.length=0; if(d && Array.isArray(d.enemies)){ for(let i=0;i<d.enemies.length;i++) enemies.push(d.enemies[i]); }
      if(d && d.world){ WORLD.current=d.world; applyTheme(WORLD.current==='main'?THEMES.main:THEMES.spawn); }
      player.vx=player.x; player.vy=player.y; pathQueue.length=0; dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
      recomputeStats(false); draw(); renderCharIfOpen(); toast('Caricato');
    }catch(e){ panic('load', e); }
  };
  btnReset.onclick=()=>location.reload();

  /* Kick loop */
  setInterval(step, 120);
  (function anim(){ updateTweens(); draw(); requestAnimationFrame(anim); })();

})();
</script>
</body>
</html>
