<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Drakoria ‚Äî Maestro + Equip Drop</title>
<style>
:root{
  --bg:#0b1224; --panel:#0f172a; --stroke:#1f2a44; --text:#e5e7eb; --muted:#9ca3af;
  --tileA:#0e2a1e; --tileB:#123022; --block:#15223b;
  --player:#3b82f6; --enemy:#ef4444; --shadow:#0006; --hpBack:#1f2937;
  --rare:#60a5fa; --epic:#a78bfa; --legend:#f59e0b;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--stroke)}
header .muted{color:var(--muted);margin-left:8px}
header .btn{background:#26325a;color:#fff;border:1px solid #31406e;border-radius:8px;padding:6px 10px;cursor:pointer}
main{max-width:1400px;margin:14px auto;padding:12px;background:var(--panel);border:1px solid var(--stroke);border-radius:12px;position:relative}
#game{display:block;width:100%;height:auto;border-radius:10px;border:1px solid var(--stroke);background:#0a1630;image-rendering:pixelated;touch-action:none}
.help{margin:.6rem 0 0;color:#a1a1aa}
#status{margin-top:8px;color:var(--muted)}
.err{position:fixed;left:50%;top:70px;transform:translateX(-50%);background:#7f1d1d;color:#fff;border:1px solid #fecaca;border-radius:8px;padding:8px 12px;z-index:50;font-weight:600;max-width:90vw;white-space:pre-wrap;display:none}
.log{position:fixed; left:16px; bottom:16px; width:300px; max-width:80vw;
  background:rgba(15,23,42,.9); border:1px solid #1f2a44; border-radius:10px; padding:8px 10px; z-index:26}
.log .h{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-weight:700}
.log .b{max-height:160px; overflow:auto; font:12px/1.3 system-ui}
.log .line{margin:2px 0}
.log .dmg{color:#fca5a5}
.log .heal{color:#86efac}
.log .sys{color:#93c5fd}
.death{position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:60}
.death.hidden{display:none}
.death-box{background:#0f172a; border:1px solid #1f2a44; padding:14px; border-radius:12px; width:min(420px,92vw); box-shadow:0 18px 44px rgba(0,0,0,.55)}
.death-title{font-weight:800; font-size:18px; margin-bottom:8px}
.death-sub{color:#cbd5e1; margin-bottom:12px}
.death-actions{display:flex; gap:8px; justify-content:flex-end}
.btn{border:1px solid #31406e;background:#2563eb;color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
.btn:disabled{background:#1f2a44;color:#9aa0ad;cursor:not-allowed}
.char{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:560px; max-width:95vw;
     background:#0f172a; border:1px solid #1f2a44; border-radius:12px; box-shadow:0 18px 44px rgba(0,0,0,.45); z-index:46}
.char-h{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #1f2a44;font-weight:700}
.char-x{width:32px;height:26px;border-radius:6px;border:1px solid #31406e;background:#26325a;color:#fff;cursor:pointer}
.char-b{padding:12px}
.stat-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
.stat{display:flex; justify-content:space-between; align-items:center; background:#0b1224; border:1px solid #2a355c; border-radius:10px; padding:8px}
.stat .k{color:#93c5fd; font-weight:700}
.stat .v{font-weight:700}
.hidden{display:none}
.subtle{color:#9ca3af;font-size:12px}
.npc{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:640px; max-width:96vw;
  background:#0f172a; border:1px solid #1f2a44; border-radius:12px; box-shadow:0 18px 44px rgba(0,0,0,.45); z-index:47}
.npc-h{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #1f2a44;font-weight:800}
.npc-x{width:32px;height:26px;border-radius:6px;border:1px solid #31406e;background:#26325a;color:#fff;cursor:pointer}
.npc-b{padding:12px}
.npc-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.npc-card{border:1px solid #2a355c;border-radius:10px;background:#0b1224;padding:10px}
.npc-card h4{margin:0 0 6px 0}
.npc-li{margin:0 0 8px 0}
.npc-li b{color:#e5e7eb}
.toast{position:fixed; left:50%; bottom:84px; transform:translateX(-50%); background:rgba(15,23,42,.9); border:1px solid #1f2a44; color:#e5e7eb; padding:6px 10px; border-radius:10px; z-index:55; display:none}
.dropcard{position:fixed; left:50%; bottom:140px; transform:translateX(-50%); background:#0b1224; border:1px solid #2a355c; color:#e5e7eb; padding:10px 12px; border-radius:12px; z-index:56; display:none; min-width:260px}
.dropcard .r{font-weight:800}
.dropcard .u{color:var(--rare)}
.dropcard .ra{color:var(--epic)}
</style>
</head>
<body>
<header>
  <div><strong>Drakoria</strong> <span class="muted">maestro + equip drop</span></div>
  <div>
    <button id="btnChar" class="btn">Personaggio</button>
    <button id="btnSave" class="btn">Save</button>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnReset" class="btn">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="1344" height="768" aria-label="Gioco"></canvas>
  <p class="help">
    Tap per muoverti ‚Ä¢ tap su un nemico per target ‚Ä¢ doppio tap/press prolungato per auto-inseguire ‚Ä¢ SPAZIO/üó°Ô∏è attacca.  
    Portale viola tra Spawn ‚Üî Main. Parla con il <b>Maestro</b> nello Spawn per info sulle Stat.
  </p>
  <div id="status"></div>
</main>

<section class="log" id="logPanel"><div class="h"><span>Log</span></div><div id="logBody" class="b"></div></section>
<div id="errBox" class="err"></div>
<div id="toast" class="toast"></div>
<div id="dropCard" class="dropcard"></div>

<div id="deathOverlay" class="death hidden" role="dialog" aria-modal="true" aria-label="Game Over">
  <div class="death-box">
    <div class="death-title">Sei morto</div>
    <div class="death-sub">Respawn ti riporta allo spawn con vita piena.</div>
    <div class="death-actions">
      <button id="deathRespawn" class="btn">Respawn</button>
      <button id="deathReset" class="btn">Reset</button>
    </div>
  </div>
</div>

<section id="charWin" class="char hidden" role="dialog" aria-modal="true" aria-label="Personaggio">
  <div class="char-h"><span>Personaggio</span><button id="charClose" class="char-x">√ó</button></div>
  <div class="char-b">
    <div id="eqInfo" class="stat-grid" style="margin-bottom:10px"></div>
    <div id="charBasics" class="stat-grid" style="margin-bottom:10px"></div>
    <div id="charStats" class="stat-grid"></div>
  </div>
</section>

<section id="npcWin" class="npc hidden" role="dialog" aria-modal="true" aria-label="Maestro">
  <div class="npc-h"><span>Maestro</span><button id="npcClose" class="npc-x">√ó</button></div>
  <div class="npc-b">
    <div class="npc-grid">
      <div class="npc-card">
        <h4>Offensive</h4>
        <p class="npc-li"><b>ATK Min/Max</b> ‚Äî da arma + bonus.</p>
        <p class="npc-li"><b>Velocit√† Attacco %</b> ‚Äî riduce il CD: <br><span class="subtle">atkCdEff = max(180ms, base * (1 - atkSpeed))</span></p>
        <p class="npc-li"><b>Crit Chance %</b> ‚Äî base + Luck.</p>
        <p class="npc-li"><b>Crit Damage %</b> ‚Äî danno critico: <br><span class="subtle">dmgCrit = base * (1 + critDmg)</span></p>
        <p class="npc-li"><b>Luck %</b> ‚Äî aumenta Crit Chance.</p>
      </div>
      <div class="npc-card">
        <h4>Difensive</h4>
        <p class="npc-li"><b>HP Max</b> ‚Äî da armatura + bonus.</p>
        <p class="npc-li"><b>Difesa</b> ‚Äî sottrae danno: <br><span class="subtle">dmg = max(0, dmg - defense)</span></p>
        <p class="npc-li"><b>Mitigazione %</b> ‚Äî riduce il resto: <br><span class="subtle">dmg = dmg * (1 - mitigation)</span> (cap 60%)</p>
        <p class="npc-li"><b>Res. Proiettili %</b> ‚Äî solo colpi arcieri: <br><span class="subtle">dopo miti</span></p>
        <p class="npc-li"><b>Res. Bleed %</b> ‚Äî riduce danni/durata sanguinamento (cap 70%).</p>
      </div>
    </div>
    <hr style="border:none;border-top:1px solid #1f2a44;margin:12px 0">
    <div id="npcValues" class="npc-card"></div>
  </div>
</section>

<script>
(function(){
  const BUILD='MAESTRO+EQUIP';
  const SAVE_KEY='save_maestro_equip';
  const cv=document.getElementById('game'); const ctx=cv.getContext('2d');
  const statusEl=document.getElementById('status');
  const errBox=document.getElementById('errBox');
  const logBody=document.getElementById('logBody');
  const toastEl=document.getElementById('toast');
  const dropCardEl=document.getElementById('dropCard');
  const deathOverlay=document.getElementById('deathOverlay');
  const deathRespawn=document.getElementById('deathRespawn');
  const deathReset=document.getElementById('deathReset');
  const btnChar=document.getElementById('btnChar');
  const charWin=document.getElementById('charWin');
  const charClose=document.getElementById('charClose');
  const eqInfo=document.getElementById('eqInfo');
  const charBasics=document.getElementById('charBasics');
  const charStats=document.getElementById('charStats');
  const npcWin=document.getElementById('npcWin');
  const npcClose=document.getElementById('npcClose');
  const npcValues=document.getElementById('npcValues');
  function panic(where,e){
    errBox.style.display='block';
    errBox.textContent='ERRORE '+where+': '+(e && (e.message||e));
    console.error('[PANIC]', where, e);
  }
  function toast(msg){
    toastEl.textContent=msg;
    toastEl.style.display='block';
    clearTimeout(toastEl.__t);
    toastEl.__t=setTimeout(()=>toastEl.style.display='none',1200);
  }
  function showDropCard(html, ttl){
    dropCardEl.innerHTML=html;
    dropCardEl.style.display='block';
    clearTimeout(dropCardEl.__t);
    dropCardEl.__t=setTimeout(()=>dropCardEl.style.display='none', ttl||1600);
  }
  function logLine(msg,cls){ const t=new Date(); const hh=String(t.getHours()).padStart(2,'0'), mm=String(t.getMinutes()).padStart(2,'0'), ss=String(t.getSeconds()).padStart(2,'0'); logBody.innerHTML+=`<div class="line ${cls||''}">[${hh}:${mm}:${ss}] ${escapeHtml(msg)}</div>`; logBody.scrollTop=logBody.scrollHeight; }
  function logDmg(m){ logLine(m,'dmg'); }
  function logHeal(m){ logLine(m,'heal'); }
  function logSys(m){ logLine(m,'sys'); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  const COLS=21, ROWS=12, TILE=64; cv.width=COLS*TILE; cv.height=ROWS*TILE;
  const WORLD={ current:'spawn', portals:makePortals() };
  const THEMES={ main:{'--tileA':'#0e2a1e','--tileB':'#123022'}, spawn:{'--tileA':'#1e1f3a','--tileB':'#23264a'} };
  let map=[];
  function makePortals(){ const mid=ROWS>>1; return { main:[{x:1,y:mid,to:'spawn',tx:COLS-2,ty:mid}], spawn:[{x:COLS-2,y:mid,to:'main',tx:1,ty:mid}] }; }
  function isPortalTile(world,x,y){ const l=WORLD.portals[world]||[]; for(let i=0;i<l.length;i++){ const p=l[i]; if(p.x===x&&p.y===y) return true; } return false; }
  function applyTheme(vars){ const root=document.documentElement.style; for(const k in vars) root.setProperty(k, vars[k]); }
  function buildMap(name){
    const m=[]; for(let y=0;y<ROWS;y++){ const row=[]; for(let x=0;x<COLS;x++) row.push(0); m.push(row); }
    if(name==='main'){ for(let i=0;i<16;i++){ const bx=(Math.random()*COLS|0), by=(Math.random()*ROWS|0); if(isPortalTile('main',bx,by)) continue; m[by][bx]=1; } }
    return {map:m, theme:(name==='main')?THEMES.main:THEMES.spawn};
  }
  function inside(x,y){ return x>=0&&y>=0&&x<COLS&&y<ROWS; }
  function rndInt(a,b){ return a+((Math.random()*(b-a+1))|0); }
  function walkable(x,y){ if(!inside(x,y)) return false; if(map[y][x]===1) return false; return true; }
  function tileFree(x,y){ if(map[y][x]!==0) return false; if(x===player.x&&y===player.y) return false; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===x&&e.y===y) return false; } return true; }
  function chebyshev(a,b){ const dx=Math.abs(a.x-b.x), dy=Math.abs(a.y-b.y); return dx>dy?dx:dy; }
  function randEmpty(){ for(let t=0;t<200;t++){ const x=rndInt(0,COLS-1), y=rndInt(0,ROWS-1); if(walkable(x,y)&&tileFree(x,y)) return {x,y}; } return {x:1,y:1}; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function getVar(n){ const cs=getComputedStyle(document.documentElement); return cs.getPropertyValue(n).trim(); }
  function bfs(sx,sy,tx,ty){
    if(!walkable(tx,ty)) return null;
    const q=[{x:sx,y:sy}], prev={}, seen={}; let head=0; seen[sx+','+sy]=1;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(head<q.length){
      const c=q[head++]; if(c.x===tx&&c.y===ty){
        const path=[]; let k=tx+','+ty;
        while(prev[k]){ const s=k.split(','); path.push({x:+s[0],y:+s[1]}); k=prev[k].x+','+prev[k].y; }
        path.reverse(); return path;
      }
      for(let d=0; d<4; d++){
        const nx=c.x+dirs[d][0], ny=c.y+dirs[d][1], kk=nx+','+ny;
        if(!walkable(nx,ny)||seen[kk]) continue; seen[kk]=1; prev[kk]={x:c.x,y:c.y}; q.push({x:nx,y:ny});
      }
    }
    return null;
  }
  function bfsToAdjacencySmart(sx,sy,tx,ty,etype){
    const opts=[[tx+1,ty],[tx-1,ty],[tx,ty+1],[tx,ty-1]]; let best=null, bestScore=1e9;
    for(let i=0;i<opts.length;i++){
      const ax=opts[i][0], ay=opts[i][1]; if(!walkable(ax,ay)) continue;
      let occ=false; for(let j=0;j<enemies.length;j++){ const e=enemies[j]; if(e.x===ax&&e.y===ay){ occ=true; break; } }
      if(occ) continue;
      const p=bfs(sx,sy,ax,ay); if(!p) continue; let score=p.length; if(etype==='ranged'&&(ax===tx||ay===ty)) score+=2;
      if(score<bestScore){ bestScore=score; best=p; }
    }
    return best;
  }
  let MOVE_MS=110;
  function startTween(o,fx,fy,tx,ty,now){ o.vFromX=fx; o.vFromY=fy; o.vToX=tx; o.vToY=ty; o.vStart=now; o.vEnd=now+MOVE_MS; if(o.vx==null)o.vx=fx; if(o.vy==null)o.vy=fy; }
  function tweenUpdate(o,now){
    if(!o) return; const has=(o.vStart&&o.vEnd&&o.vEnd>o.vStart);
    if(has && now<o.vEnd){ let t=(now-o.vStart)/(o.vEnd-o.vStart); t=t*t*(3-2*t); o.vx=o.vFromX+(o.vToX-o.vFromX)*t; o.vy=o.vFromY+(o.vToY-o.vFromY)*t; }
    else { if(o.x!=null) o.vx=o.x; if(o.y!=null) o.vy=o.y; o.vStart=0; o.vEnd=0; }
  }
  function updateTweens(){ const now=performance.now(); tweenUpdate(player,now); for(let i=0;i<enemies.length;i++) tweenUpdate(enemies[i],now); for(let j=0;j<projectiles.length;j++) tweenUpdate(projectiles[j],now); }
  const player={
    x:12,y:4,
    baseMaxHp:100, baseAtkMin:6, baseAtkMax:12,
    maxHp:100, hp:100, atkMin:6, atkMax:12,
    baseCrit:0.10,
    coins:0,pots:1,lastAtk:0,atkCd:450,lvl:1,exp:0,
    stats:{ atkSpeed:0.00, critDmg:0.50, luck:0.00, defense:0, mitigation:0.00, projRes:0.00, bleedRes:0.00 },
    status:{ bleed:null }
  };
  let equipped={
    weapon:{ name:'Coltellino', slot:'weapon', rarity:'common', icon:'üó°Ô∏è', atkBonus:0, affix:{} },
    armor: { name:'Tunica', slot:'armor', rarity:'common', icon:'üõ°Ô∏è', hpBonus:0, affix:{} }
  };
  const MAX_LVL=99;
  function xpNeeded(l){ return Math.floor(50 * Math.pow(l, 1.5)); }
  function gainXP(n){
    if(player.lvl>=MAX_LVL) return;
    player.exp+=n;
    while(player.lvl<MAX_LVL && player.exp>=xpNeeded(player.lvl)){
      player.exp-=xpNeeded(player.lvl); levelUp();
    }
    renderCharIfOpen(); renderNpcValues();
  }
  function levelUp(){
    player.lvl=Math.min(MAX_LVL, player.lvl+1);
    player.baseMaxHp += 2; player.baseAtkMin += .2; player.baseAtkMax += .3;
    if(player.lvl%5===0){
      player.stats.defense += 1;
      player.stats.mitigation = clamp((player.stats.mitigation||0)+.01,0,0.60);
      player.stats.atkSpeed   = clamp((player.stats.atkSpeed  ||0)+.01,0,0.50);
      player.stats.projRes    = clamp((player.stats.projRes   ||0)+.01,0,0.60);
      player.stats.bleedRes   = clamp((player.stats.bleedRes  ||0)+.01,0,0.70);
      player.stats.luck       = clamp((player.stats.luck      ||0)+.005,0,0.50);
    }
    player.hp=Math.min(player.maxHp, player.hp + Math.round(player.maxHp*0.10));
    recomputeStats(false);
    logSys('Level up ‚Üí LV '+player.lvl);
    toast('LV '+player.lvl);
  }
  function effectiveStat(name){
    let v = player.stats[name]||0;
    if(equipped.weapon && equipped.weapon.affix && equipped.weapon.affix[name]) v += equipped.weapon.affix[name];
    if(equipped.armor  && equipped.armor .affix && equipped.armor .affix[name]) v += equipped.armor .affix[name];
    return v;
  }
  function getCritChance(){ return clamp(player.baseCrit + effectiveStat('luck'), 0, 0.90); }
  function getCritMult(){ return 1 + effectiveStat('critDmg'); }
  function getAtkCd(){ const eff=player.atkCd*(1-clamp(effectiveStat('atkSpeed'),0,0.50)); return Math.max(180, Math.floor(eff)); }
  function recomputeStats(heal){
  const atkB = ((equipped && equipped.weapon && equipped.weapon.atkBonus) || 0) | 0;
  const hpB  = ((equipped && equipped.armor  && equipped.armor.hpBonus ) || 0) | 0;

  player.maxHp = Math.round(player.baseMaxHp + hpB);
  player.atkMin = Math.round(player.baseAtkMin + atkB);
  player.atkMax = Math.round(player.baseAtkMax + atkB);

  if(heal) player.hp = player.maxHp;
  if(player.hp > player.maxHp) player.hp = player.maxHp;

  renderCharIfOpen();
  renderNpcValues();
}

  let enemies=[], projectiles=[];
  let _eid=1; function giveId(e){ e.id=_eid++; return e; }
  function makeArcher(x,y){
    const e={ kind:'archer', type:'ranged', x,y, spawnX:x, spawnY:y,
      hp:44, maxHp:44, atkCd:1200, lastShot:0, rangeMin:3, rangeMax:7,
      aggro:false, aggroRange:5, leashRange:15, loseAggroMs:6000, lastSeenTs:0,
      moveTick:0, moveEvery:6, path:[], windupMs:400
    };
    e.vx=x; e.vy=y; return giveId(e);
  }
  function createPatrolGroup(count, anchorX, anchorY, radius){
    for(let i=0;i<count;i++){
      const pos=findFreeNear(anchorX,anchorY,radius||2,30);
      const e=makeArcher(pos.x,pos.y);
      e.groupAnchor={x:anchorX,y:anchorY}; e.patrolRadius=radius||2;
      enemies.push(e);
    }
  }
  function spawnMain(){
    enemies.length=0;
    createPatrolGroup(5, COLS-5, 2, 2);
    createPatrolGroup(5, COLS-5, ROWS-3, 2);
  }
  function findFreeNear(cx,cy,r,tries){ tries=tries||30;
    for(let k=0;k<tries;k++){ const nx=clamp(Math.round(cx+rndInt(-r,r)),0,COLS-1), ny=clamp(Math.round(cy+rndInt(-r,r)),0,ROWS-1);
      if(walkable(nx,ny)&&tileFree(nx,ny)&&!isPortalTile(WORLD.current,nx,ny)) return {x:nx,y:ny};
    } return randEmpty();
  }
  const NPCS=[];
  function makeMaestro(x,y){
    return { kind:'maestro', x, y, w:1, h:1, name:'Maestro', icon:'üßô‚Äç‚ôÇÔ∏è' };
  }
  function ensureSpawnNpcs(){
    if(!NPCS.find(n=>n.kind==='maestro')){
      const mid=ROWS>>1;
      const pos={x:Math.max(2, COLS-6), y:mid-3};
      NPCS.push(makeMaestro(pos.x,pos.y));
    }
  }
  (function initSpawn(){
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn'; enemies.length=0; recomputeStats(true);
    ensureSpawnNpcs();
  })();
  const HUD={ atk:null, pot:null, char:null };
  function layoutHud(){
    HUD.atk  = { x: cv.width - 86,  y: cv.height - 86, w: 72, h: 72 };
    HUD.pot  = { x: cv.width - 166, y: cv.height - 86, w: 72, h: 72 };
    HUD.char = { x: cv.width - 86,  y: 14,             w: 72, h: 54  };
  }
  window.addEventListener('resize', layoutHud, false);
  layoutHud();
  let target=null, autoChase=false, lastEnemyTapTs=0, lastEnemyTapId=-1;
  let pathQueue=[], holdTimer=null, destMarker=null;
  let dead=false;
  btnChar.onclick=()=>{ charWin.classList.toggle('hidden'); renderCharPanel(); };
  charClose.onclick=()=>{ charWin.classList.add('hidden'); };
  npcClose.onclick=()=>npcWin.classList.add('hidden');
  function canvasToTile(ev){
    const r=cv.getBoundingClientRect(), t=ev.touches&&ev.touches[0];
    const cx=t?t.clientX:ev.clientX, cy=t?t.clientY;
    const sx=(cx-r.left)*(cv.width/r.width), sy=(cy-r.top)*(cv.height/r.height);
    const tx = Math.max(0, Math.min(COLS-1, (sx/TILE)|0));
    const ty = Math.max(0, Math.min(ROWS-1, (sy/TILE)|0));
    return {sx, sy, tx, ty};
  }
  function enemyRect(e){ const x=e.x*TILE+TILE/2-16, y=e.y*TILE+TILE/2-22; return {x,y,w:32,h:36}; }
  function inRect(px,py,r){ return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h; }
  function getEnemyAtScreen(sx,sy){ for(let i=0;i<enemies.length;i++){ const ee=enemies[i]; if(inRect(sx,sy,enemyRect(ee))) return ee; } return null; }
  function npcRect(n){ const x=n.x*TILE+TILE/2-16, y=n.y*TILE+TILE/2-24; return {x,y,w:32,h:40}; }
  function getNpcAtScreen(sx,sy){
    if(WORLD.current!=='spawn') return null;
    for(let i=0;i<NPCS.length;i++){ const n=NPCS[i]; if(inRect(sx,sy,npcRect(n))) return n; }
    return null;
  }
  function onPointerDown(ev){
    if(dead) return;
    const m=canvasToTile(ev), pos={sx:m.sx,sy:m.sy};
    clearTimeout(holdTimer);
    holdTimer=setTimeout(()=>{ const enemy=getEnemyAtScreen(pos.sx,pos.sy); if(enemy){ target=enemy; autoChase=true; pathQueue=[]; updateTargetFrame(); toast('Auto-inseguimento'); draw(); } },500);
  }
  function onPointerUp(ev){
    if(dead) return;
    clearTimeout(holdTimer);
    const m=canvasToTile(ev), now=performance.now();
    if(inRect(m.sx,m.sy,HUD.atk)){ tryAttackAdjacent(); return; }
    if(inRect(m.sx,m.sy,HUD.pot)){ usePotion(); return; }
    if(inRect(m.sx,m.sy,HUD.char)){ charWin.classList.toggle('hidden'); renderCharPanel(); return; }
    const npc=getNpcAtScreen(m.sx,m.sy);
    if(npc){ openMaestro(); return; }
    const clicked=getEnemyAtScreen(m.sx,m.sy);
    if(clicked){
      if(lastEnemyTapId===clicked.id && (now-lastEnemyTapTs)<=350){ target=clicked; autoChase=true; pathQueue=[]; }
      else { target=clicked; autoChase=false; }
      lastEnemyTapId=clicked.id; lastEnemyTapTs=now; updateTargetFrame(); draw(); return;
    }
    autoChase=false;
    const p=bfs(player.x,player.y,m.tx,m.ty);
    if(p && p.length){ pathQueue=p; destMarker={x:m.tx,y:m.ty,ttl:1400}; }
    else{
      const dx=Math.sign(m.tx-player.x), dy=Math.sign(m.ty-player.y);
      const tryFirst=(Math.abs(m.tx-player.x)>=Math.abs(m.ty-player.y))?[{x:player.x+dx,y:player.y},{x:player.x,y:player.y+dy}]:[{x:player.x,y:player.y+dy},{x:player.x+dx,y:player.y}];
      for(let k=0;k<tryFirst.length;k++){ const nxt=tryFirst[k]; if(inside(nxt.x,nxt.y)&&walkable(nxt.x,nxt.y)){ pathQueue=[nxt]; destMarker={x:nxt.x,y:nxt.y,ttl:700}; break; } }
    }
    if(target && chebyshev(player,target)===1 && (now-player.lastAtk)>=getAtkCd()) { attackEnemy(target); return; }
    draw(); updateTargetFrame();
  }
  cv.addEventListener('pointerdown', onPointerDown, {passive:false});
  cv.addEventListener('pointerup', onPointerUp, {passive:false});
  cv.addEventListener('click', onPointerUp, false);
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.key===' ') tryAttackAdjacent(); }, false);
  function tryAttackAdjacent(){
    const now=performance.now(); if(now-player.lastAtk<getAtkCd()) return false;
    if(target && chebyshev(player,target)===1){ attackEnemy(target); return true; }
    for(let i=0;i<enemies.length;i++){ const en=enemies[i]; if(chebyshev(player,en)===1){ attackEnemy(en); return true; } }
    return false;
  }
  const dmgTexts=[];
  function addDmgText(tx,ty,txt,color){ const px=tx*TILE+TILE/2, py=ty*TILE+TILE/2-28; dmgTexts.push({x:px,y:py,txt,color,ttl:700,vy:-0.04}); }
  function updateDmgTexts(dt){ for(let i=dmgTexts.length-1;i>=0;i--){ const d=dmgTexts[i]; d.ttl-=dt; d.y+=d.vy*dt; if(d.ttl<=0) dmgTexts.splice(i,1); } }
  function drawDmgTexts(){ for(let i=0;i<dmgTexts.length;i++){ const d=dmgTexts[i]; const a=Math.max(0,Math.min(1,d.ttl/700)); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=d.color; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(d.txt,d.x,d.y); ctx.restore(); } }
  function rollCrit(ch){ return Math.random() < ch; }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
  function genWeapon(rarity){
    const baseNames={ uncommon:['Pugnale Rozzo','Spada Leggera','Ascia di Rame'], rare:['Lama del Falco','Sciabola Runica'] };
    const icon='üó°Ô∏è';
    const atkBonus = rarity==='rare' ? rndInt(3,5) : rndInt(1,3);
    const aff={};
    const pool=[ 'atkSpeed','critDmg','luck' ];
    const nAff = rarity==='rare' ? 2 : 1;
    for(let i=0;i<nAff;i++){
      const k=pick(pool.filter(x=>!(x in aff)));
      if(k==='atkSpeed') aff[k] = +(rarity==='rare' ? (Math.random()*0.05+0.03).toFixed(3) : (Math.random()*0.04+0.02).toFixed(3));
      if(k==='critDmg') aff[k]   = +(rarity==='rare' ? (Math.random()*0.12+0.08).toFixed(3) : (Math.random()*0.08+0.05).toFixed(3));
      if(k==='luck') aff[k]      = +(rarity==='rare' ? (Math.random()*0.06+0.03).toFixed(3) : (Math.random()*0.05+0.02).toFixed(3));
    }
    const name=pick(baseNames[rarity]);
    return {slot:'weapon', icon, name, rarity, atkBonus, affix:aff};
  }
  function genArmor(rarity){
    const baseNames={ uncommon:['Giaco di Pelle','Mantello Grezzo','Cotta Leggera'], rare:['Corazza del Cacciatore','Mantello del Falco'] };
    const icon='üõ°Ô∏è';
    const hpBonus = rarity==='rare' ? rndInt(14,22) : rndInt(8,16);
    const aff={};
    const pool=[ 'defense','mitigation','projRes','bleedRes' ];
    const nAff = rarity==='rare' ? 2 : 1;
    for(let i=0;i<nAff;i++){
      const k=pick(pool.filter(x=>!(x in aff)));
      if(k==='defense') aff[k]    = rndInt(rarity==='rare'?3:1, rarity==='rare'?6:3);
      if(k==='mitigation') aff[k] = +(rarity==='rare' ? (Math.random()*0.04+0.02).toFixed(3) : (Math.random()*0.03+0.01).toFixed(3));
      if(k==='projRes') aff[k]    = +(rarity==='rare' ? (Math.random()*0.05+0.02).toFixed(3) : (Math.random()*0.04+0.01).toFixed(3));
      if(k==='bleedRes') aff[k]   = +(rarity==='rare' ? (Math.random()*0.08+0.03).toFixed(3) : (Math.random()*0.06+0.02).toFixed(3));
    }
    const name=pick(baseNames[rarity]);
    return {slot:'armor', icon, name, rarity, hpBonus, affix:aff};
  }
  function maybeDropEquip(){
    if(Math.random()<0.25){
      const isWeapon = Math.random()<0.6;
      const rarity = Math.random()<0.7 ? 'uncommon' : 'rare';
      return isWeapon ? genWeapon(rarity) : genArmor(rarity);
    }
    return null;
  }
  function itemScore(it){
    if(it.slot==='weapon'){
      const a = (it.atkBonus||0)*3;
      const s = (it.affix.atkSpeed||0)*100;
      const c = (it.affix.critDmg||0)*120;
      const l = (it.affix.luck||0)*80;
      return a+s+c+l;
    }else{
      const h = (it.hpBonus||0)*1.2;
      const d = (it.affix.defense||0)*2.0;
      const m = (it.affix.mitigation||0)*200;
      const p = (it.affix.projRes||0)*150;
      const b = (it.affix.bleedRes||0)*120;
      return h+d+m+p+b;
    }
  }
  function currentScore(slot){
    if(slot==='weapon'){ return itemScore({slot:'weapon', atkBonus:(equipped.weapon.atkBonus||0), affix:equipped.weapon.affix||{}}); }
    return itemScore({slot:'armor', hpBonus:(equipped.armor.hpBonus||0), affix:equipped.armor.affix||{}});
  }
  function equipItem(it){
    if(it.slot==='weapon') equipped.weapon = it;
    else equipped.armor = it;
    recomputeStats(false);
    renderCharIfOpen();
  }
  function formatAffix(aff){
    const out=[];
    for(const k in aff){
      const v=aff[k];
      if(k==='atkSpeed') out.push(`Vel. Attacco +${Math.round(v*100)}%`);
      if(k==='critDmg')  out.push(`Crit Dmg +${Math.round(v*100)}%`);
      if(k==='luck')     out.push(`Luck +${Math.round(v*100)}%`);
      if(k==='defense')  out.push(`Difesa +${v}`);
      if(k==='mitigation') out.push(`Mitigazione +${Math.round(v*100)}%`);
      if(k==='projRes')  out.push(`Res. Proiettili +${Math.round(v*100)}%`);
      if(k==='bleedRes') out.push(`Res. Bleed +${Math.round(v*100)}%`);
    }
    return out.join(' ¬∑ ');
  }
  function rarityClass(r){ return r==='rare'?'ra':'u'; }
  function handleDrop(){
    const it=maybeDropEquip(); if(!it) return;
    const mainStat = it.slot==='weapon' ? `ATK +${it.atkBonus}` : `HP +${it.hpBonus}`;
    const affTxt = formatAffix(it.affix);
    const cls = rarityClass(it.rarity);
    const html = `<div class="r ${cls}">${it.icon} ${escapeHtml(it.name)} <small>(${it.rarity})</small></div>
                  <div>${mainStat}</div>
                  <div class="subtle">${escapeHtml(affTxt)}</div>`;
    const scoreNew=itemScore(it), scoreCur=currentScore(it.slot);
    if(scoreNew>scoreCur){
      equipItem(it);
      showDropCard(html+`<div style="margin-top:6px;color:#22c55e;font-weight:700">Auto-equip!</div>`, 1800);
      logSys(`Equip ottenuto: ${it.name} (${it.rarity}) ‚Üí auto-equip`);
    }else{
      const coinsGain = it.rarity==='rare' ? rndInt(8,12) : rndInt(4,7);
      player.coins += coinsGain;
      showDropCard(html+`<div style="margin-top:6px;color:#93c5fd">Inferiore ‚Üí +${coinsGain} monete</div>`, 1600);
      logSys(`Equip scartato: +${coinsGain} monete`);
    }
  }
  function attackEnemy(t){
    const now=performance.now(); player.lastAtk=now;
    const base=rndInt(player.atkMin,player.atkMax);
    const crit=rollCrit(getCritChance()); const mult=crit?getCritMult():1;
    const dmg=Math.max(0, Math.floor(base*mult));
    t.hp=Math.max(0, t.hp-dmg);
    addDmgText(t.x,t.y,(crit?'CRIT ':'-')+dmg, crit?'#facc15':'#ffd166');
    if(t.hp===0){
      if(target===t){ target=null; autoChase=false; }
      logSys('Nemico sconfitto. +25 XP');
      enemies.splice(enemies.indexOf(t),1);
      gainXP(25);
      handleDrop();
      setTimeout(()=>{ if(WORLD.current==='main'){ const s=randEmpty(); enemies.push(makeArcher(s.x,s.y)); } }, 1000);
    }
    draw();
  }
  function applyDamageReduction(amount, source){
    let dmg=Math.max(0, amount-(effectiveStat('defense')|0));
    const miti=clamp(effectiveStat('mitigation'),0,0.60); dmg=Math.floor(dmg*(1-miti));
    if(source==='projectile'){ const pr=clamp(effectiveStat('projRes'),0,0.60); dmg=Math.floor(dmg*(1-pr)); }
    return Math.max(0,dmg|0);
  }
  function takePlayerDamage(amount,label,source){
    const dmg=applyDamageReduction(amount,source);
    player.hp=Math.max(0, player.hp-dmg); addDmgText(player.x,player.y,label+dmg,'#ff6b6b');
    if(player.hp===0) gameOver();
  }
  function usePotion(){
    if(player.pots<=0||player.hp>=player.maxHp) return;
    player.pots--; const heal=35; player.hp=Math.min(player.maxHp, player.hp+heal);
    logHeal('Pozione: +'+heal+' HP'); draw();
  }
  function gameOver(){
    dead=true; autoChase=false; pathQueue=[]; target=null;
    cv.style.filter='grayscale(1)'; cv.style.opacity='0.6';
    deathOverlay.classList.remove('hidden');
  }
  deathRespawn.onclick=()=>{
    const res=buildMap('spawn'); map=res.map; applyTheme(res.theme); WORLD.current='spawn';
    const exit=findSafeExit('spawn', COLS-2, (ROWS>>1), 1);
    setPlayerPos(exit.x, exit.y);
    player.hp=player.maxHp;
    enemies.length=0; projectiles.length=0; pathQueue=[];
    ensureSpawnNpcs();
    dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
    teleportGuardUntil=performance.now()+600;
    entryAggroSilenceUntil=performance.now()+900;
    draw();
  };
  deathReset.onclick=()=>location.reload();
  function hasLoS(ax,ay,bx,by){
    if(ax===bx){ const step=(ay<by)?1:-1; for(let y=ay+step; y!==by; y+=step){ if(map[y][ax]===1) return false; } return true; }
    if(ay===by){ const st=(ax<bx)?1:-1; for(let x=ax+st; x!==bx; x+=st){ if(map[ay][x]===1) return false; } return true; }
    return false;
  }
  let teleportGuardUntil=0;
  let entryAggroSilenceUntil=0;
  let mustMoveOffExit=false;
  let lastExit={x:-1,y:-1};
  function setPlayerPos(x,y){ player.x=x; player.y=y; player.vx=x; player.vy=y; }
  function findSafeExit(worldName, px, py, minGapFromPortal){
    const gap = (minGapFromPortal==null)?1:minGapFromPortal;
    const candidates = [
      [ 1, 0],[-1, 0],[ 0, 1],[ 0,-1],
      [ 1, 1],[-1, 1],[ 1,-1],[-1,-1],
      [ 2, 0],[-2, 0],[ 0, 2],[ 0,-2],
      [ 3, 0],[-3, 0],[ 0, 3],[ 0,-3]
    ];
    function isNearPortal(wx,wy){ const list=WORLD.portals[worldName]||[]; for(let i=0;i<list.length;i++){ const p=list[i]; if(Math.abs(wx-p.x)<=gap && Math.abs(wy-p.y)<=gap) return true; } return false; }
    for(const d of candidates){
      const nx=clamp(px+d[0],0,COLS-1), ny=clamp(py+d[1],0,ROWS-1);
      if(!walkable(nx,ny)) continue;
      if(isPortalTile(worldName,nx,ny)) continue;
      if(isNearPortal(nx,ny)) continue;
      if(!tileFree(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    let fx=clamp(px+1,0,COLS-1), fy=py;
    if(!walkable(fx,fy) || isPortalTile(worldName,fx,fy)) fx=clamp(px-1,0,COLS-1);
    return {x:fx,y:fy};
  }
  function checkPortalEnter(){
    const now=performance.now();
    if(now<teleportGuardUntil) return false;
    if(mustMoveOffExit && player.x===lastExit.x && player.y===lastExit.y) return false;
    const list=WORLD.portals[WORLD.current]||[];
    for(let i=0;i<list.length;i++){
      const p=list[i];
      if(p.x===player.x && p.y===player.y){
        const next = buildMap(p.to); map=next.map; applyTheme(next.theme); WORLD.current=p.to;
        if(WORLD.current==='main'){ spawnMain(); } else { enemies.length=0; projectiles.length=0; ensureSpawnNpcs(); }
        const exit = findSafeExit(p.to, p.tx, p.ty, 1);
        setPlayerPos(exit.x, exit.y);
        pathQueue.length=0;
        teleportGuardUntil = performance.now()+600;
        entryAggroSilenceUntil = performance.now()+900;
        mustMoveOffExit = true;
        lastExit = {x:exit.x, y:exit.y};
        logSys('Teletrasporto: '+(WORLD.current==='main'?'Main':'Spawn'));
        draw();
        return true;
      }
    }
    return false;
  }
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?getVar('--block'):(((x+y)%2===0)?getVar('--tileA'):getVar('--tileB'));
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
    drawPortals();
    if(WORLD.current==='spawn'){
      for(let i=0;i<NPCS.length;i++){ const n=NPCS[i]; drawNpc(n); }
    }
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; const ex=(e.vx!=null?e.vx:e.x), ey=(e.vy!=null?e.vy:e.y);
      drawActor(ex,ey,getVar('--enemy'));
      drawHpBar(ex,ey,e.hp,e.maxHp,true,(target===e));
      if(target===e) drawTargetRing(ex,ey);
    }
    const pxv=(player.vx!=null?player.vx:player.x), pyv=(player.vy!=null?player.vy:player.y);
    drawActor(pxv,pyv,getVar('--player')); drawHpBar(pxv,pyv,player.hp,player.maxHp,false,false);
    for(let p=0;p<projectiles.length;p++){
      const pr=projectiles[p]; const ptx=(pr.vx!=null?pr.vx:pr.x), pty=(pr.vy!=null?pr.vy:pr.y);
      const x=ptx*TILE+TILE/2, y=pty*TILE+TILE/2; ctx.fillStyle='#f87171'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
    }
    drawDmgTexts();
    drawHud();
    const need=(player.lvl<MAX_LVL)?xpNeeded(player.lvl):1;
    const ratio=(player.lvl<MAX_LVL)?Math.min(1,player.exp/need):1;
    const guardLeft=Math.max(0, teleportGuardUntil - performance.now())|0;
    const aggroSilLeft=Math.max(0, entryAggroSilenceUntil - performance.now())|0;
    statusEl.textContent=`build:${BUILD} | LV ${player.lvl} ${player.lvl<MAX_LVL?('('+Math.floor(ratio*100)+'%)'):''} | HP ${player.hp}/${player.maxHp} | ATK ${player.atkMin}‚Äì${player.atkMax} | monete ${player.coins} | AggroSil ${aggroSilLeft}ms | TPGuard ${guardLeft}ms`;
  }
  function drawPortals(){
    const list=WORLD.portals[WORLD.current]||[];
    ctx.save();
    for(let i=0;i<list.length;i++){
      const p=list[i];
      ctx.fillStyle='#7c3aed'; ctx.globalAlpha=0.95; ctx.fillRect(p.x*TILE+6,p.y*TILE+6,TILE-12,TILE-12);
      ctx.globalAlpha=0.35; ctx.fillRect(p.x*TILE+3,p.y*TILE+3,TILE-6,TILE-6);
    }
    ctx.restore();
  }
  function drawActor(tx,ty,color){
    const x=tx*TILE, y=ty*TILE;
    ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,18,6,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=color; ctx.fillRect(x+TILE/2-16,y+TILE/2-22,32,36);
  }
  function drawHpBar(tx,ty,hp,maxHp,isEnemy,isTarget){
    const x=tx*TILE, y=ty*TILE, w=40, h=6, px=x+TILE/2-w/2, py=y+TILE/2-32;
    const r=Math.max(0,Math.min(1,hp/maxHp));
    let col='#10b981'; if(isEnemy){ if(r<0.66) col='#f59e0b'; if(r<0.33) col='#ef4444'; }
    ctx.fillStyle=getVar('--hpBack'); ctx.fillRect(px,py,w,h);
    ctx.fillStyle=col; ctx.fillRect(px,py,w*r,h);
    ctx.strokeStyle=isTarget?'#f87171':'#0008'; ctx.lineWidth=isTarget?2:1; ctx.strokeRect(px,py,w,h); ctx.lineWidth=1;
  }
  function drawTargetRing(tx,ty){ const x=tx*TILE+TILE/2, y=ty*TILE+TILE/2; ctx.save(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,28,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function drawHudBtn(r, glyph, enabled){ ctx.save(); ctx.globalAlpha=enabled?1:0.55; ctx.fillStyle='rgba(15,23,42,.85)'; ctx.strokeStyle='#1f2a44'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(r.x+12,r.y); ctx.arcTo(r.x+r.w,r.y,r.x+r.w,r.y+r.h,12); ctx.arcTo(r.x+r.w,r.y+r.h,r.x,r.y+r.h,12); ctx.arcTo(r.x,r.y+r.h,r.x,r.y,12); ctx.arcTo(r.x,r.y,r.x+r.w,r.y,12); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.font='28px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#e5e7eb'; ctx.fillText(glyph, r.x + r.w/2, r.y + r.h/2); ctx.restore(); }
  function drawHud(){
    drawHudBtn(HUD.atk, 'üó°Ô∏è', (performance.now()-player.lastAtk)>=getAtkCd());
    drawHudBtn(HUD.pot, 'üçµ', player.pots>0);
    drawHudBtn(HUD.char, 'üë§', true);
    if(destMarker && destMarker.ttl>0){
      const a=Math.min(1, destMarker.ttl/400);
      ctx.save(); ctx.globalAlpha=a; ctx.strokeStyle='#93c5fd'; ctx.lineWidth=2;
      const cx=destMarker.x*TILE+TILE/2, cy=destMarker.y*TILE+TILE/2;
      ctx.beginPath(); ctx.arc(cx,cy,20,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }
  function drawNpc(n){
    const x=n.x*TILE, y=n.y*TILE;
    ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-10,16,6,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#6d28d9'; ctx.fillRect(x+TILE/2-16, y+TILE/2-22, 32, 36);
    ctx.fillStyle='#eab308'; ctx.font='18px system-ui'; ctx.textAlign='center';
    ctx.fillText('üßô‚Äç‚ôÇÔ∏è', x+TILE/2, y+TILE/2-10);
    ctx.fillStyle='#e5e7eb'; ctx.font='12px system-ui'; ctx.fillText('Maestro', x+TILE/2, y+TILE/2+26);
  }
  function updateTargetFrame(){}
  function movedOffExitTile(){ return !(player.x===lastExit.x && player.y===lastExit.y); }
  let lastStepTs=performance.now();
  function step(){
    try{
      const now=performance.now();
      const dt=Math.min(200, now-lastStepTs)|0; lastStepTs=now;
      if(mustMoveOffExit && movedOffExitTile()) mustMoveOffExit=false;
      if(!dead && pathQueue.length){
        const next=pathQueue[0];
        let blocked=!walkable(next.x,next.y);
        for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.x===next.x&&e.y===next.y){ blocked=true; break; } }
        if(blocked){ pathQueue.length=0; }
        else{
          const fx=player.x, fy=player.y; setPlayerPos(next.x,next.y); startTween(player,fx,fy,player.x,player.y,now);
          pathQueue.shift();
        }
      }
      checkPortalEnter();
      for(let j=0;j<enemies.length;j++){
        const e=enemies[j];
        e.moveTick=(e.moveTick+1)%e.moveEvery;
        const canMove=(e.moveTick===0);
        const distC=chebyshev(e,player);
        if(!e.aggro && now>=entryAggroSilenceUntil){
          const canAggro = (distC<=e.aggroRange) && (hasLoS(e.x,e.y,player.x,player.y) || distC<=2);
          if(canAggro){ e.aggro=true; e.lastSeenTs=now; }
        }
        const tooFar = chebyshev({x:e.spawnX,y:e.spawnY}, player) > e.leashRange || distC > e.leashRange;
        if(e.aggro){
          if(hasLoS(e.x,e.y,player.x,player.y) || distC<=1) e.lastSeenTs=now;
          if(tooFar || (now - e.lastSeenTs) > e.loseAggroMs){
            e.aggro=false; e.path = bfs(e.x,e.y,e.spawnX,e.spawnY)||[];
          }
        }
        if(e.aggro && now>=entryAggroSilenceUntil){
          const distM=Math.abs(e.x-player.x)+Math.abs(e.y-player.y);
          const inRange = (distM>=e.rangeMin && distM<=e.rangeMax && hasLoS(e.x,e.y,player.x,player.y));
          if(inRange){
            if(now-e.lastShot>=e.atkCd){
              e.lastShot=now;
              setTimeout(()=>{
                const dx=(player.x===e.x)?0:(player.x>e.x?1:-1);
                const dy=(player.y===e.y)?0:(player.y>e.y?1:-1);
                if(dx||dy) projectiles.push({x:e.x,y:e.y,dx,dy,spdTick:0,dmg:rndInt(6,10), vx:e.x, vy:e.y, vStart:0,vEnd:0, bleedChance:0.3});
              }, e.windupMs);
            }
            if(distM<e.rangeMin && canMove){
              const backX=e.x + (player.x<e.x?1:(player.x>e.x?-1:0));
              const backY=e.y + (player.y<e.y?1:(player.y>e.y?-1:0));
              if(walkable(backX,backY) && !(backX===player.x&&backY===player.y)){
                const fx=e.x, fy=e.y; e.x=backX; e.y=backY; startTween(e,fx,fy,e.x,e.y,now);
              }
            }
          } else if(canMove){
            if(chebyshev(e,player)>1 || !hasLoS(e.x,e.y,player.x,player.y)){
              e.path = bfsToAdjacencySmart(e.x,e.y,player.x,player.y,'ranged') || e.path || [];
            }
            tryStepAlongPath(e, now);
          }
        } else if(canMove){
          if((e.x!==e.spawnX || e.y!==e.spawnY)){
            if(!e.path || !e.path.length) e.path=bfs(e.x,e.y,e.spawnX,e.spawnY)||[];
            tryStepAlongPath(e, now);
          }
        }
      }
      for(let pi=projectiles.length-1; pi>=0; pi--){
        const pr=projectiles[pi];
        pr.spdTick=(pr.spdTick+1)%2; if(pr.spdTick!==0) continue;
        const nx=pr.x+pr.dx, ny=pr.y+pr.dy;
        if(!inside(nx,ny) || map[ny][nx]===1){ projectiles.splice(pi,1); continue; }
        if(nx===player.x && ny===player.y){
          const base=rndInt(pr.dmg-1, pr.dmg+1);
          takePlayerDamage(base, '-', 'projectile');
          projectiles.splice(pi,1); continue;
        }
        startTween(pr, pr.x, pr.y, nx, ny, now); pr.x=nx; pr.y=ny;
      }
      if(autoChase && target && !dead){
        const stillThere = enemies.indexOf(target)!==-1;
        if(!stillThere){ autoChase=false; target=null; }
        if(target){
          if(chebyshev(player,target)!==1 && pathQueue.length===0){
            const pAdj=bfsToAdjacencySmart(player.x,player.y,target.x,target.y,target.type);
            if(pAdj && pAdj.length) pathQueue=pAdj;
          }
          if(chebyshev(player,target)===1){
            const nowA=performance.now(); if(nowA-player.lastAtk>=getAtkCd()) attackEnemy(target);
          }
        }
      }
      updateDmgTexts(dt);
      if(destMarker){ destMarker.ttl-=dt; if(destMarker.ttl<=0) destMarker=null; }
      updateTweens();
      draw();
    }catch(e){ panic('step', e); }
  }
  function tryStepAlongPath(e, now){
    if(!e.path || !e.path.length) return;
    const nxt=e.path.shift();
    if(!walkable(nxt.x,nxt.y)) { e.path=[]; return; }
    for(let k=0;k<enemies.length;k++){ const other=enemies[k]; if(other!==e && other.x===nxt.x && other.y===nxt.y){ e.path=[]; return; } }
    if(nxt.x===player.x && nxt.y===player.y){ e.path=[]; return; }
    const fx=e.x, fy=e.y; e.x=nxt.x; e.y=nxt.y; startTween(e,fx,fy,e.x,e.y,now);
  }
  function pct(v){ return Math.round((v||0)*100); }
  function renderCharPanel(){
    if(charWin.classList.contains('hidden')) return;
    const need=(player.lvl<MAX_LVL)?xpNeeded(player.lvl):1;
    const basics=[
      ['Livello','LV '+player.lvl],
      ['XP',''+player.exp+' / '+(player.lvl<MAX_LVL?need:'‚Äî')],
      ['HP',''+player.hp+' / '+player.maxHp],
      ['Attacco',''+player.atkMin+'‚Äì'+player.atkMax],
      ['Crit Chance', pct(getCritChance())+'%'],
      ['Crit Damage', pct(effectiveStat('critDmg'))+'%'],
      ['CD Attacco', getAtkCd()+' ms']
    ];
    const stats=[
      ['Difesa (flat)', (effectiveStat('defense')|0)],
      ['Mitigazione', pct(clamp(effectiveStat('mitigation'),0,0.60))+'%'],
      ['Res. Proiettili', pct(clamp(effectiveStat('projRes'),0,0.60))+'%'],
      ['Res. Bleed', pct(clamp(effectiveStat('bleedRes'),0,0.70))+'%'],
      ['Vel. Attacco', pct(clamp(effectiveStat('atkSpeed'),0,0.50))+'%'],
      ['Luck (Crit +)', pct(effectiveStat('luck'))+'%']
    ];
    const eq=[
      ['Arma', `${equipped.weapon.icon} ${equipped.weapon.name} <span class="subtle">(${equipped.weapon.rarity})</span><br>ATK +${equipped.weapon.atkBonus||0} <span class="subtle">¬∑ ${escapeHtml(formatAffix(equipped.weapon.affix||{}))}</span>`],
      ['Armatura', `${equipped.armor.icon} ${equipped.armor.name} <span class="subtle">(${equipped.armor.rarity})</span><br>HP +${equipped.armor.hpBonus||0} <span class="subtle">¬∑ ${escapeHtml(formatAffix(equipped.armor.affix||{}))}</span>`]
    ];
    eqInfo.innerHTML =eq.map(kv=>`<div class="stat" style="grid-column:span 1"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
    charBasics.innerHTML=basics.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
    charStats.innerHTML =stats.map(kv=>`<div class="stat"><span class="k">${kv[0]}</span><span class="v">${kv[1]}</span></div>`).join('');
  }
  function renderCharIfOpen(){ renderCharPanel(); }
  function renderNpcValues(){
    if(npcWin.classList.contains('hidden')) return;
    const rows=[
      `ATK: <b>${player.atkMin}‚Äì${player.atkMax}</b>`,
      `CD Attacco: <b>${getAtkCd()} ms</b>`,
      `Crit Chance: <b>${pct(getCritChance())}%</b> ¬∑ Crit Dmg: <b>${pct(effectiveStat('critDmg'))}%</b>`,
      `HP Max: <b>${player.maxHp}</b>`,
      `Difesa: <b>${effectiveStat('defense')|0}</b> ¬∑ Mitigazione: <b>${pct(clamp(effectiveStat('mitigation'),0,0.60))}%</b>`,
      `Res. Proiettili: <b>${pct(clamp(effectiveStat('projRes'),0,0.60))}%</b> ¬∑ Res. Bleed: <b>${pct(clamp(effectiveStat('bleedRes'),0,0.70))}%</b>`,
      `Vel. Attacco: <b>${pct(clamp(effectiveStat('atkSpeed'),0,0.50))}%</b> ¬∑ Luck: <b>${pct(effectiveStat('luck'))}%</b>`
    ];
    npcValues.innerHTML = `<div><b>Valori Attuali</b></div><div class="subtle">${rows.join(' ¬∑ ')}</div>`;
  }
  function openMaestro(){
    npcWin.classList.remove('hidden');
    renderNpcValues();
  }
  const btnSave=document.getElementById('btnSave');
  const btnLoad=document.getElementById('btnLoad');
  const btnReset=document.getElementById('btnReset');
  btnSave.onclick=()=>{
    try{
      localStorage.setItem(SAVE_KEY, JSON.stringify({map, player, enemies, world:WORLD.current, equipped}));
      toast('Salvato');
    }catch(e){ panic('save', e); }
  };
  btnLoad.onclick=()=>{
    try{
      const raw=localStorage.getItem(SAVE_KEY); if(!raw) return alert('Nessun salvataggio.');
      const d=JSON.parse(raw);
      if(d && d.map && d.map.length===ROWS){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) map[y][x]=d.map[y][x]|0; }
      if(d && d.player){ for(const k in d.player){ if(d.player.hasOwnProperty(k)) player[k]=d.player[k]; } }
      if(d && d.equipped){ equipped=d.equipped; }
      enemies.length=0; if(d && Array.isArray(d.enemies)){ for(let i=0;i<d.enemies.length;i++) enemies.push(d.enemies[i]); }
      if(d && d.world){ WORLD.current=d.world; applyTheme(WORLD.current==='main'?THEMES.main:THEMES.spawn); }
      if(WORLD.current==='spawn') ensureSpawnNpcs(); else NPCS.length=0;
      setPlayerPos(player.x,player.y); pathQueue.length=0; dead=false; deathOverlay.classList.add('hidden'); cv.style.filter=''; cv.style.opacity='';
      recomputeStats(false); draw(); renderCharIfOpen(); renderNpcValues(); toast('Caricato');
    }catch(e){ panic('load', e); }
  };
  btnReset.onclick=()=>location.reload();
  setInterval(step, 120);
  (function anim(){ updateTweens(); draw(); requestAnimationFrame(anim); })();
})();
</script>
</body>
</html>
